{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Magewire PHP - V3","text":"<p>Beta release</p> <p>Do not use Magewire V3 in production, as its stability, security, and overall reliability cannot be guaranteed. The framework is still in an beta phase, and breaking changes may occur without warning. Using it in a live environment is entirely at your own risk and may lead to unexpected issues, including potential security vulnerabilities and system instability.</p> <p>Please refer to the beta page for more details.</p> <p>These docs are still under active development, with the goal of providing as much useful content as possible. Given that Magewire is a large package with many possibilities, it's challenging to cover everything out of the box. We appreciate your understanding.</p> <p>Welcome to the official documentation for Magewire PHP. This guide provides all the necessary information to get started with Magewire V3, understand its core concepts, and build dynamic Magento applications using Livewire-like components.</p> <p>Understanding Magewire Documentation and Its Relation to Livewire</p> <p>Magewire is heavily inspired by Livewire, and as a result, most of its core functionality works in the same way. For this reason, all essential documentation can be found in the official Livewire documentation. The Magewire documentation primarily focuses on Magento-specific implementations, custom features, and additional explanations that are either missing from the Livewire docs or are not relevant due to platform differences. If you're looking for a deeper understanding of how Magewire works under the hood, we highly recommend referring to the Livewire documentation alongside this guide.</p>"},{"location":"index.html#what-is-magewire","title":"What is Magewire?","text":"<p>MagewirePHP is a powerful framework for Magento 2 that enables developers to build reactive and dynamic user interfaces without writing JavaScript. It is inspired by Laravel Livewire and offers a similar development experience within the Magento ecosystem.</p> <p>Magewire comes with Alpine JS preloaded as the primary JavaScript engine behind the framework. If you are using Alpine JS within your theme, make sure to disable your version to prevent it from being loaded twice, as this can cause conflicts.</p> <p>Each theme should have its own submodule on top of Magewire to ensure compatibility. Theme-specific modifications, such as custom events and loading files, are required for proper functionality. By default, Magewire is built on the Hyv\u00e4 theme, but this integration can easily be disabled, as it is a separate compatibility module rather than part of the core architecture.</p>"},{"location":"index.html#so-much-more","title":"So Much More","text":"<p>Both Livewire and Magewire are known for their dynamic capabilities powered by XHR (AJAX) requests. This can sometimes be intimidating, as making a full server round trip just to update a small piece of HTML may seem excessive\u2014let alone concerns about potential deadlocks or other pitfalls.</p> <p>However, Magewire is much more than just a framework that standardizes XHR requests and morphs returned HTML into the existing DOM. It's a powerful and feature-rich framework that caters to both backend and frontend developers. Its seamless integration with Alpine JS makes the two feel like a natural pair.</p> <p>Magewire isn't limited to dynamic interactivity alone. It offers a wide range of possibilities and use cases\u2014many of which you'll only begin to appreciate as you explore its full potential.</p> <p>You can learn more about the purpose of Magewire here.</p>"},{"location":"index.html#requirements","title":"Requirements","text":"<p>Before we start, make sure you have the following installed:</p> <ul> <li>Magento 2.4.4 or later</li> <li>PHP 8.1 or later</li> </ul>"},{"location":"index.html#installation","title":"Installation","text":"<p>To install Magewire in your Magento 2 project, follow these steps:</p> <ol> <li>Require Magewire via Composer:    <pre><code>composer require magewirephp/magewire\n</code></pre></li> <li>Enable the module:    <pre><code>bin/magento module:enable Magewirephp_Magewire\n</code></pre></li> <li>Enable the theme compatibility module (determined per theme, in this case Hyv\u00e4):    <pre><code>bin/magento module:enable Magewirephp_MagewireCompatibilityWithHyva\n</code></pre></li> <li>Run the setup upgrade command:    <pre><code>bin/magento setup:upgrade\n</code></pre></li> <li>Deploy static content (when in production mode):    <pre><code>bin/magento setup:static-content:deploy\n</code></pre></li> <li>Flush the cache:    <pre><code>bin/magento cache:flush\n</code></pre></li> </ol>"},{"location":"index.html#quickstart","title":"Quickstart","text":"<p>Details</p> <p>This quickstart guide does not cover all the details behind the \"why\" and \"how\" but is intended to provide a concise overview of creating a basic Layout XML-driven Magewire component.</p> <p>Let's create a simple Magewire component to demonstrate its basic capabilities.</p>"},{"location":"index.html#1-create-a-component-class","title":"1. Create a Component class","text":"<p>Create a new component class:</p> File: Magewire/Counter.php<pre><code>&lt;?php\n\nnamespace Vendor\\Module\\Magewire;\n\nclass Counter extends \\Magewirephp\\Magewire\\Component\n{\n    public int $count = 0;\n\n    public function increment(): void\n    {\n        $this-&gt;count++;\n    }\n}\n</code></pre> <p>Note: It is advisable to keep your components inside the <code>Magewire</code> root directory of your module, either as direct children or nested within subdirectories.</p>"},{"location":"index.html#2-create-a-template-file","title":"2. Create a Template File","text":"<p>Now, create the corresponding template file:</p> File: view/frontend/templates/magewire/counter.phtml<pre><code>&lt;div&gt;\n    Counter: &lt;?= $magewire-&gt;count ?&gt;\n\n    &lt;button wire:click=\"increment\"&gt;\n        Increase\n    &lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <p>Note: Every Magewire component binds its state to the first HTML element in its template. This means you must always wrap your component's content in a root HTML element, such as a <code>&lt;div&gt;</code>, to ensure proper functionality.</p>"},{"location":"index.html#3-inject-onto-a-page","title":"3. Inject onto a page","text":"<p>To render the component, add the following to your layout handle:</p> File: view/frontend/layout/page_handle.xml<pre><code>&lt;referenceBlock name=\"content\"&gt;\n    &lt;block name=\"counter.block\" template=\"Vendor_Module::magewire/counter.phtml\"&gt;\n        &lt;arguments&gt;\n            &lt;argument name=\"magewire\" xsi:type=\"object\"&gt;\n                Vendor\\Module\\Magewire\\Counter\n            &lt;/argument&gt;\n        &lt;/arguments&gt;\n    &lt;/block&gt;\n&lt;/referenceBlock&gt;\n</code></pre> <p>Note: This is the standard method for injecting a Magewire component into your page. However, alternatives exist through component resolvers, allowing more flexible integration. You can even create a custom resolver to fit specific requirements.</p>"},{"location":"index.html#4-test-it-out","title":"4. Test it out","text":"<p>Clear the Magento cache and navigate to the relevant page:</p> <pre><code>bin/magento cache:flush\n</code></pre> <p>Congratulations! You have successfully created your first Magewire component.</p> <p>When you click the button, you'll notice the count updates instantly without a full page reload. This is the power of Magewire\u2014seamless, dynamic frontend interactions built entirely in PHP.</p> <p>We've only scratched the surface of what Magewire can do. Continue exploring the documentation to unlock its full potential!</p> <p>Full Page Cache (FPC)</p> <p>Since a Magewire component's state is determined by the JSON objects bound to the component, cached pages will naturally retain the cached state rather than the most recent one. As of now, there is no definitive solution, though some experimental approaches are being explored. The most viable option currently is using wire:init to load the state on page load, though this requires an XHR request when the component is initialized.</p>"},{"location":"index.html#support","title":"Support","text":"<p>Security Vulnerabilities</p> <p>If you discover a security vulnerability within Magewire, please create a merge request or an discussion. All security vulnerabilities will be promptly addressed.</p> <p>Magewire is a fully open-source project, meaning support is provided voluntarily by its contributors and the surrounding community.</p> <p>To request support, you can start a discussion or open an issue on our GitHub Repository.</p>"},{"location":"index.html#next-steps","title":"Next Steps","text":"<p>With Magewire, there are a few key concepts worth understanding if you want to go beyond the basics\u2014like binding a <code>magewire</code> argument to a block via Layout XML.</p> Description Resolvers While Magewire supports various methods for binding components to blocks, some scenarios require custom handling. For those, an API is available to help you tailor the solution to your needs. Portman To contribute to Magewire, it's important to understand the idea behind Portman. We've provided extensive documentation to guide you and help you get up to speed quickly. <p>Some other great resources to get you started are:</p> <ul> <li>Basics</li> <li>Examples</li> <li>FAQ</li> <li>Notables</li> <li>Upgrade</li> <li>Architecture</li> </ul> <p>For further details, visit the MagewirePHP GitHub Repository.</p>"},{"location":"blogs/index.html","title":"Blog","text":""},{"location":"blogs/2025/09/08/magewire-3---beta-release.html","title":"Magewire 3 - Beta Release","text":"","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#yes-its-been-a-while","title":"Yes, it\u2019s been a while","text":"<p>The months have flown by. On the surface the repo may have seemed quiet, but nothing could be further from the truth.</p> <p>Behind the scenes, I\u2019ve been working in a separate branch on a hefty list of additions that I absolutely wanted to include in the upcoming beta release.</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#critical-security-vulnerability","title":"Critical Security Vulnerability","text":"<p>The biggest strength of Magewire, and one of the main reasons I took on this challenge, is the incredible community already behind Livewire. Livewire has already proven itself as one of the two biggest game changers in the Laravel community.</p> <p>This means Magewire is not just another new brew of technology in the Magento ecosystem, it\u2019s already a proven solution similar to e.g. AlpineJS.</p> <p>A good example is security: on July 17th, a critical security issue was fixed in the Livewire repository, and within just 10 minutes, the same fix was applied to Magewire thanks to the way it has been built (ported).</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#so-whats-next","title":"So What's Next?","text":"<p>Feature building has stopped for now. It\u2019s time to focus on improving testing across the board, ensuring everything remains backwards compatible, and writing documentation on how to migrate.</p> <p>In the meantime, I\u2019m trying to establish a small team to speed things up. But I\u2019ve found that asking for help and getting valuable input is really a struggle\u2014which I totally understand.</p> <p>Open source in our money-driven community is incredibly difficult, with most people either waiting until something gets released, or creating a clone of what Magewire already is and ending up in the same rabbit hole.</p> <p>It\u2019s somewhat discouraging, but I suppose that\u2019s the reality :D</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#so-whats-new","title":"So What's New?","text":"<p>I\u2019d like to take you along for a look at what\u2019s been happening, and honestly, these additions are features I\u2019m incredibly excited about.</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#fragments","title":"Fragments","text":"<p>Fragments are a way to convert HTML into what we call a fragment, both inside your template files and even within PHP files. At its core, it\u2019s nothing more than wrapping a piece of HTML so you can give it a name.</p> <p>The real benefit, however, lies in what you can do with it afterwards. For example, you can treat a fragment directly as a CSP block whenever it involves a <code>&lt;script&gt;&lt;/script&gt;</code>. And thanks to modifiers, you can centrally manage your fragments without touching a single template.</p> <p>Fragments were initially intended as a better solution to make scripts CSP-compliant. However, they eventually grew into much more, where they are no longer only needed for CSP or for wrapping <code>&lt;script&gt;</code> elements.</p> <pre><code>&lt;?php $script = $magewireFragment-&gt;make()-&gt;script()-&gt;start() ?&gt;\n&lt;script&gt;\n    ...\n&lt;/script&gt;\n&lt;?php $script-&gt;end() ?&gt;\n</code></pre> <p>Please refer to the documentation for more details.</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#template-directives","title":"Template Directives","text":"<p>As you might know from Laravel, Magewire now also supports the use of <code>@</code> directives inside your Magewire component templates.</p> <p>Simply put: if you want to display something inside your component only to a logged-in user, you can just wrap it with <code>@auth</code> and <code>@endauth</code>.</p> <p>The nice part is that this system is built in such a way that you can extend it with your own prefixes.</p> <p>For example, you could create a <code>@{agencyNameGoesHere}CustomerGroup(1)</code> directive, which ensures content is only shown when the customer is logged in and belongs to customer group 1. This directive would then belong to the <code>agencyNameGoesHere</code> group (area to be specific).</p> <p>And don\u2019t worry: thanks to the built pre-compiler, everything is precompiled into actual PHP in advance, so nothing happens on the fly.</p> <pre><code>&lt;div&gt;\n    @guest\n        &lt;!-- Will only be shown to guests. --&gt;\n        &lt;span&gt;Hi guest&lt;/span&gt;\n    @endguest\n&lt;/div&gt;\n</code></pre> <p>Please refer to the documentation for more details.</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#flakes","title":"Flakes","text":"<p>I really wanted to create a \u201cgood\u201d system that lets you easily add re-usable components inside your Magewire components using nothing more than simple HTML syntax. No complicated stuff, no need for additional ViewModels or other workarounds, just like in the following example.</p> <pre><code>class Dialog extends Component\n{\n    public string $title = '';\n\n    public function mount(string $fooBar, AbstractBlock $block)\n    {\n        //\n    }\n}\n</code></pre> <p>Where your template simply looks like this:</p> <pre><code>&lt;?php $title = 'Hello World'; ?&gt;\n\n&lt;magewire:dialog name=\"my-component\"\n                 prop:title=\"$title\"\n                 mount:block=\"$block\"\n                 mount:foo-bar=\"baz\"\n/&gt;\n</code></pre> <p>As you can see, you can easily inject public properties, pass mount method arguments, and use template variables as an attribute value.</p> <p>Please refer to the documentation for more details.</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#stream-directive","title":"Stream Directive","text":"<p>The Streaming feature has been made compatible and now works within Magewire.</p> <p>Thanks to the Portman tool we built, it only took about 15 minutes to get it running.</p> <p>Fortunately, this feature isn\u2019t too complicated, but it does provide you with some cool new options.</p> <p>Please refer to the documentation for more details.</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#rate-limiting","title":"Rate Limiting","text":"<p>Livewire does not officially support this, but for many reasons I felt it was needed, so I went ahead and built it.</p> <p>Rate limiting can now be applied in multiple ways. One option is via the frontend using <code>wire:mage:throttle</code>, where most of the handling happens on the client side. This is not bulletproof, though, since a smart user could easily work around it.</p> <p>That\u2019s why server-side rate limiting has also been added. Based on system configuration, you can now limit the number of subsequent requests within a specific time window.</p> <p>Cool thing, by default, its cache driven, but you can build your own adapter if you'd like.</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#observer-events","title":"Observer Events","text":"<p>It\u2019s not always easy to learn a new framework, I know that. That\u2019s why, wherever possible, we should provide an approach that already feels familiar to you as a Magento developer.</p> <p>For every hook you can tap into, an observer event is automatically dispatched. This means you don\u2019t have to create a separate Feature for just a small tweak. Instead, you can simply add an event in your <code>events.xml</code> and use the provided Data Transfer Object (DTO) to pass data along to the hook.</p> <p>Please refer to the documentation for more details.</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/09/08/magewire-3---beta-release.html#backend-compatibility","title":"Backend Compatibility","text":"<p>Yes, Magewire is coming to the backend. All you need to do is require the new module <code>magewirephp/magewire-admin</code>.</p> <p>I\u2019m currently wrapping up the final details, and then nothing will hold us back from using this powerhouse of a framework in the backend as well.</p>","tags":["V3","release","beta"]},{"location":"blogs/2025/05/24/magewire-3---docs-publication.html","title":"Magewire 3 - Docs Publication","text":"","tags":["documentation","V3","release"]},{"location":"blogs/2025/05/24/magewire-3---docs-publication.html#kicking-off-a-new-chapter-for-magewire","title":"Kicking Off a New Chapter for Magewire","text":"<p>First, I\u2019m excited to share that starting today, all future updates about Magewire will be posted right here in the blog section of the documentation.</p> <p>This shift is all about keeping things simple and centralized. No more jumping between websites to find the latest news or resources\u2014everything you need will now live alongside the docs.</p>","tags":["documentation","V3","release"]},{"location":"blogs/2025/05/24/magewire-3---docs-publication.html#the-wait-is-kind-of-over","title":"The Wait Is (Kind of) Over!","text":"<p>For those who\u2019ve been patiently waiting: the long silence is finally breaking\u2014at least in terms of documentation.</p> <p>I\u2019ve spent months putting together the foundation, and while there\u2019s still some work to be done, I\u2019ve decided to release the docs ahead of the actual beta launch.</p> <p>My goal is to give you a head start\u2014to inspire, to motivate, and to let you explore what's coming in Magewire V3.</p> <p>The beta code itself is planned for release by June 1st. I just need a few more evening sessions to get it over the finish line.</p>","tags":["documentation","V3","release"]},{"location":"blogs/2025/05/24/magewire-3---docs-publication.html#a-work-in-progress-literally","title":"A Work in Progress (Literally)","text":"<p>Let me be upfront: the documentation is still very much a work in progress.</p> <p>You\u2019ll see a few <code>WIP...</code> tags sprinkled throughout. These are simply placeholders and reminders for myself\u2014sections that still need attention.</p>","tags":["documentation","V3","release"]},{"location":"blogs/2025/05/24/magewire-3---docs-publication.html#why-this-release-matters","title":"Why This Release Matters","text":"<p>The main goal right now is to help developers get started with V3 as early as possible. By putting the documentation out there, I\u2019m hoping to lay the groundwork for the community to join in and help shape its future.</p> <p>That said, this is still a passion project\u2014one I mostly work on during evenings and weekends\u2014so progress might not always be rapid. Thanks in advance for your patience and understanding.</p>","tags":["documentation","V3","release"]},{"location":"blogs/2025/05/24/magewire-3---docs-publication.html#whats-next","title":"What\u2019s Next?","text":"<p>In about a week, I\u2019ll push the V3 beta under a new beta tag in the Magewire GitHub repository (which you probably already know your way around).</p> <p>From there, things become a little less predictable. The pace of development will depend on a lot of factors, including time, feedback, and community involvement.</p> <p>Thanks for being part of this journey. Let\u2019s make something awesome together.</p>","tags":["documentation","V3","release"]},{"location":"blogs/2025/06/02/magewire-3---hello-world.html","title":"Magewire 3 - Hello World","text":"","tags":["V3","release"]},{"location":"blogs/2025/06/02/magewire-3---hello-world.html#here-we-go","title":"Here We Go!","text":"<p>A promise is a promise. I said Magewire V3 would be released a week after the docs went live, and I'm a man who sticks to his word\u2014even if V3 isn't quite where I'd like it to be yet.</p> <p>From this point forward, we're going to build this airplane while it's getting ready to take off. Luckily, we're still taxiing on the runway, and as long as that <code>beta</code> tag stays on, we'll keep it grounded until it's ready to fly.</p>","tags":["V3","release"]},{"location":"blogs/2025/06/02/magewire-3---hello-world.html#the-journey-is-what-matters-most","title":"The Journey Is What Matters Most","text":"<p>They say it all the time\u2014the journey itself is more important than the destination, and that's no different with Magewire. I've learned an incredible amount as a professional, but also as a person, during this development process. For me, it's been such a beautiful experience to work on something where I could completely let loose on how I wanted the architecture to be.</p> <p>Through all the years working with Magento 1 and Magento 2, I've always had an extreme interest in architecture and kept challenging myself to improve, try new things, and sometimes go a bit outside the lines of old-school Magento standards. Not everyone always appreciates that, but I figure\u2014if I don't try it and make mistakes, how are we ever going to make Magento attractive to the new generation of developers who really do think differently?</p> <p>The road has been pretty long, and fortunately, the endpoint isn't in sight yet. Even though many people ask me why I invest so much free time in something that doesn't pay back in a community like ours. I can't say anything other than\u2014this is completely true. The investment is ridiculous, and sometimes I ask myself that same question: what am I doing all this for?</p> <p>For me, the answer is simple: it makes me incredibly happy. Working on my own thing, not constantly having to worry about what someone thinks of it, and just being able to pour all my knowledge into an ultimate project that I couldn't imagine working without in my daily work anymore.</p>","tags":["V3","release"]},{"location":"blogs/2025/06/02/magewire-3---hello-world.html#now-for-the-serious-stuff","title":"Now for the Serious Stuff","text":"<p>V3\u2014a lot of the same, plus some innovations that came about partly through necessary things like CSP and other things I've had on my wishlist for a long time but could never really make happen in Magewire V1.</p> <p>The architecture is solid now, but not everything that's standard in V1 is in V3 yet. There's still plenty that needs to be ported over, but I expect this will go much faster now that all the tools are available. So over the coming months, that's roughly the plan for the beta\u2014to work (hopefully together) toward a version that at least contains everything V1 has.</p>","tags":["V3","release"]},{"location":"blogs/2025/06/02/magewire-3---hello-world.html#whats-new","title":"What's New?","text":"<p>Good question. There are many new features like Fragments, which let you mark sections in your PHTML and tweak them using modifiers. Fragments came about because of CSP\u2014I wanted a tool I could wrap around a <code>script</code> block and then optionally modify based on different variables, like adding a <code>nonce</code> attribute or creating a hash of the content and passing it to Magento's CSP collection. I've expanded this concept to offer other fragments in the future. You could think of feature flags, for example where you can show part of your PHTML only based on a specific version of another package.</p> <p>There's also a new <code>@</code> compiler that allows you to use so-called <code>@</code>-directives in your PHTML that automatically get converted to valid PHP during compilation. This creates cleaner, more readable PHTML, but also means less actual PHP code in the PHTML files. There's much less need for all kinds of View Models and Helpers to get things done. I have some really exciting ideas in the pipeline for this feature that I hope to add soon. The groundwork is already laid.</p> <p>Of course, the completely new documentation shouldn't be forgotten either. I'm glad I set this up because I can now write about things much more specifically compared to the previous approach where everything was buried on a single page in the Magewire repository itself. The domain name might still change to make it easier to find, but the first steps have been taken.</p> <p>There's so much innovation that I could write endlessly about it, but I think it's smarter for you to take a look at the documentation to get a good picture of what might be relevant for you.</p>","tags":["V3","release"]},{"location":"blogs/2025/06/02/magewire-3---hello-world.html#finally","title":"Finally","text":"<p>I'll try to write a blog post every month about Magewire's progress, but I won't make a LinkedIn post about it every time. So definitely keep an eye on this blog page if you're interested in more reading material about this project!</p> <p>And if you feel the urge to contribute, whether through code or financially, I invite you to get in touch!</p>","tags":["V3","release"]},{"location":"pages/advanced/best-practices.html","title":"Best Practices","text":""},{"location":"pages/advanced/best-practices.html#modules-structure","title":"Modules Structure","text":"<p>When creating a module, we encourage you to follow a consistent directory and file structure to keep things organized and familiar\u2014similar to how View Models are typically placed in a <code>ViewModel</code> folder.</p> <p>For modules, we tend to have the general rule to keep everything within the Magewire folder:</p> <p><code>src/Magewire/--/-</code></p> <p>All your components should be stored in a dedicated directory\u2014either directly or organized within subdirectories\u2014to keep the structure clean and maintainable.</p> <p><code>src/Magewire/Features/</code></p> <p>Use a subdirectory named after your feature, starting with a capital letter.</p> <p><code>src/Magewire/Mechanisms/</code></p> <p>Use a subdirectory named after your mechanisms, starting with a capital letter.</p> <p><code>src/view/{area}/template/magewire/--/-</code></p> <p>All component templates should be stored in a dedicated directory\u2014either directly or organized within subdirectories\u2014to keep the structure clean and maintainable.</p> <p>src/view/{area}/templates/js/magewire/features/{feature-name}</p> <p>WIP...</p> <p>src/view/{area}/templates/js/magewire/directives/{directive-name}</p> <p>WIP...</p>"},{"location":"pages/advanced/patterns.html","title":"Patterns","text":"<p>While entirely optional, these patterns serve as recommended approaches. They\u2019re open to discussion and improvement\u2014as we\u2019re always learning and evolving to make Magewire better for everyone.</p> <p>Instead of sharing numerous GitHub Gists, we prefer to share the patterns used within the Magewire core package itself. These patterns are the result of extensive experimentation and refinement, carefully crafted to keep things clean, consistent, and maintainable.</p>"},{"location":"pages/advanced/patterns.html#magewire-object-on-init-event","title":"Magewire object on init event","text":"<p>While waiting for Magewire to initialize, you can import any function from the global Magewire object.</p> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    // This shows only a small subset of available options.\n    const { addons, utilities, dispatch, on } = event.detail.magewire;\n});\n</code></pre>"},{"location":"pages/advanced/patterns.html#alpinejs-function-proxy","title":"AlpineJS Function Proxy","text":"<p>Need to extend or override an AlpineJS component function that's registered with <code>Alpine.data()</code>?</p> <p>This pattern lets you proxy the function regardless of DOM script order.</p> <p>Original Component <pre><code>&lt;script&gt;\n    function magewireNotifier() {\n        'use strict';\n\n        const notifier = Magewire.addons.notifier;\n\n        return {\n            terminate: function() {\n                notifier.terminate(this.notification.id);\n            }\n        };\n    }\n\n    document.addEventListener('alpine:init', () =&gt; Alpine.data('magewireNotifier', magewireNotifier), { once: true });\n&lt;/script&gt;\n</code></pre></p> <p>Proxy Implementation <pre><code>&lt;script&gt;\n    (function() {\n        const original = window.magewireNotifier;\n\n        window.magewireNotifier = function() {\n            const result = original();\n            const terminate = result.terminate;\n\n            // Extend the terminate method\n            result.terminate = function() {\n                // You can still access the notification using `this.notification`.\n\n                console.log('Custom logic before terminate', this.notification);\n                terminate.call(this);\n                console.log('Custom logic after terminate');\n            };\n\n            return result;\n        };\n    })();\n&lt;/script&gt;\n</code></pre></p>"},{"location":"pages/advanced/security.html","title":"Security","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/advanced/synthesizers.html","title":"Synthesizers","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/advanced/themes.html","title":"Themes","text":"<p>Magewire is Hyv\u00e4-compatible out of the box, meaning we actively design features to work seamlessly with the Hyv\u00e4 theme. However, it\u2019s absolutely possible to integrate Magewire with other themes as well.</p> <p>While this may require more effort, Magewire\u2019s event-driven architecture and minimalist file structure make it flexible. Many components can be moved, extended, or overridden as needed to support different frontends.</p>"},{"location":"pages/advanced/themes.html#supported-themes","title":"Supported Themes","text":"Theme Parent Hyv\u00e4 Theme Hyv\u00e4 Reset Magento Admin -"},{"location":"pages/advanced/themes.html#compatibility","title":"Compatibility","text":"<p>Making a theme compatible with Magewire requires a solid understanding of Magewire\u2019s frontend architecture, including its folder and file structure, dispatched events, available features, utilities, addons, and custom directives.</p> <p>Additionally, Magewire relies heavily on AlpineJS as its core frontend engine. If your theme already includes AlpineJS, you\u2019ll need to either remove your version in favor of the one bundled with Magewire or disable it on pages where Magewire is used to avoid conflicts.</p> <p>Below is an example of how dispatched flash messages from a component can be made compatible:</p> src/Magewire/Example.php<pre><code>&lt;?php\n\nnamespace Example\\Module\\Magewire\\Example;\n\nclass Example extends \\Magewirephp\\Magewire\\Component\n{\n    public function click(): void\n    {\n        $this-&gt;dispatchSuccessMessage(__('Hello World'))\n    }\n}\n</code></pre> <p>By default, there is no frontend event listener for the <code>magewire:flash-messages:dispatch</code> event. To make this work, a compatibility layer needs to be added.</p> <p>In the case of the Hyv\u00e4 Theme, the following approach can be used:</p> src/view/frontend/layout/default_hyva.xml<pre><code>&lt;body&gt;\n    &lt;referenceContainer name=\"magewire.features\"&gt;\n        &lt;block name=\"magewire.features.support-magento-flash-messages\"\n               template=\"Magewirephp_MagewireCompatibilityWithHyva::js/magewire/features/support-magento-flash-messages/support-magento-flash-messages.phtml\"\n        /&gt;\n    &lt;/referenceContainer&gt;\n&lt;/body&gt;\n</code></pre> <p>Here\u2019s the template content used to achieve this:</p> Magewirephp_MagewireCompatibilityWithHyva::js/magewire/features/support-magento-flash-messages/support-magento-flash-messages.phtml<pre><code>&lt;script&gt;\n    (() =&gt; {\n        window.addEventListener('magewire:flash-messages:dispatch', event =&gt; dispatchMessages(event.detail));\n    })();\n&lt;/script&gt;\n</code></pre> <p>The <code>magewire:flash-messages:dispatch</code> event includes the following data:</p> <pre><code>{\n    \"detail\": {\n        \"0\": {\n            \"text\": \"Hello World\",\n            \"type\": \"success\"\n        }\n    }\n}\n</code></pre> <p>So, in theory, it only takes eight lines of code to make flash messages work with the Hyv\u00e4 Theme.</p>"},{"location":"pages/advanced/troubleshooting.html","title":"Troubleshooting","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/advanced/architecture/index.html","title":"Architecture","text":"<p>Considerable research was conducted to devise a practical and comprehensible approach to porting Livewire into a Magento module, while maintaining a straightforward architecture to encourage broader contribution.</p>"},{"location":"pages/advanced/architecture/index.html#module","title":"Module","text":"<p>The module structure differs slightly from a typical Magento module.</p> Directory Description <code>./dist</code> The classes generated by Portman are based on the configuration source and any overrides, following a similar folder structure to the one found in the <code>./portman</code> directory. <code>./lib</code> Contains framework-related classes, including core Features and Mechanisms. <code>./portman</code> Specific Portman class overwrites. <code>./src</code> Core structure serving as the initial entry point, binding key elements to Magento. <code>./tests</code> Multiple type of tests e.g. Playwright <code>./themes</code> Theme support decided into sub-modules"},{"location":"pages/advanced/architecture/index.html#themes","title":"Themes","text":"<p>Magewire is build to support multiple themes with having the Hyv\u00e4 theme as its default. A theme needs to be made compatible adding or overwriting specific theme related code re-using the javascript which is written in a modular and loosly coupled fashion.</p>"},{"location":"pages/advanced/architecture/index.html#example","title":"Example","text":"<p>Among other things, some theme-specific adjustments for Hyv\u00e4 were necessary \u2014 in this example, the flash messages are being made compatible.</p> page/js/magewire/features/support-magento-flash-messages.phtml<pre><code> &lt;script&gt;\n    (() =&gt; {\n        window.addEventListener('magewire:flash-messages:dispatch', event =&gt; {\n            dispatchMessages(event.detail)\n        })\n    })()\n&lt;/script&gt;\n</code></pre> <p>The <code>magewire:flash-messages:dispatch</code> event is triggered by the MagentoFlashMessages feature. An array containing a <code>name</code> and its corresponding <code>params</code>, in this case, the flash messages extracted from the component during dehydration, is pushed into the <code>dispatches</code> property.</p> Magewirephp\\Magewire\\Features\\SupportMagentoFlashMessages\\SupportMagentoFlashMessages<pre><code>&lt;?php\n\n...\n\nclass SupportMagentoFlashMessages extends \\Magewirephp\\Magewire\\ComponentHook\n{\n    public function dehydrate(\\Magewirephp\\Magewire\\Mechanisms\\HandleComponents\\ComponentContext $context): void\n    {\n        ...\n\n        $context-&gt;pushEffect('dispatches', [\n            'name'   =&gt; 'magewire:flash-messages:dispatch',\n            'params' =&gt; $messages,\n        ]);\n    }\n}\n</code></pre>"},{"location":"pages/advanced/architecture/component-hooks.html","title":"Component Hooks","text":"<p>Livewire Concept</p> <p>WIP...</p>"},{"location":"pages/advanced/architecture/facades.html","title":"Facades (experimental)","text":"<p>Experimental</p> <p>Experimental features are still in development and may change, break, or be removed in future versions. Use with caution and provide feedback where possible.</p> <p>Feature and Mechanism facades are currently experimental and may not be included in the final release. While they aim to simplify development, they can also introduce complexity for those unfamiliar with the concept. Magewire is designed to align closely with Magento\u2019s core principles, though some necessary deviations have been made. Facades, however, are not essential but rather a convenience feature. We welcome feedback on this approach, which is why we have provided some documentation to facilitate discussion.</p>"},{"location":"pages/advanced/architecture/facades.html#understanding-facades","title":"Understanding Facades","text":"<p>Facades in PHP provide a simple interface to complex class structures. In Magewire, they serve as entry points to features and mechanisms.</p>"},{"location":"pages/advanced/architecture/facades.html#why-use-facades","title":"Why Use Facades?","text":"<p>Magento development often involves interacting with multiple services, which can lead to tightly coupled, verbose code. Facades streamline this by offering a clear, expressive API that abstracts away complexity, ensuring better maintainability and flexibility.</p>"},{"location":"pages/advanced/architecture/facades.html#some-key-benefits","title":"Some Key Benefits","text":"<ul> <li>Simplifies Complex Systems \u2013 Encapsulates intricate logic, allowing developers to focus on business requirements rather than low-level details.</li> <li>Enhances Code Readability \u2013 Provides well-named methods that make the API easier to understand and use.</li> <li>Promotes Loose Coupling \u2013 Shields client code from underlying changes, making the system more adaptable to future modifications.</li> </ul>"},{"location":"pages/advanced/architecture/facades.html#development-best-practices","title":"Development Best Practices","text":"<p>Not every feature or mechanism requires a facade; their implementation is at the developer\u2019s discretion.</p> <p>Facades are structured within their respective feature or mechanism subdirectories, maintaining clarity and consistency. This organization ensures that developers can efficiently integrate Magewire\u2019s capabilities into their Magento projects.</p>"},{"location":"pages/advanced/architecture/facades.html#using-a-facade","title":"Using a Facade","text":"<p>When your feature becomes big or you want to provide a simple entry to a reusable piece of code, you may decide to implement a facade for your feature or mechanism. This is done via <code>di.xml</code>, where you inject your feature or mechanism into the service provider. By using the <code>facade</code> item key, you can assign a facade class, making it accessible.</p> <pre><code>&lt;item name=\"example_feature_name\" xsi:type=\"array\"&gt;\n    &lt;item name=\"type\" xsi:type=\"string\"&gt;\n        ...\n    &lt;/item&gt;\n\n    &lt;item name=\"facade\" xsi:type=\"string\"&gt;\n        Vendor\\Module\\Features\\ExampleFeature\\ExampleFeatureFacade\n    &lt;/item&gt;\n&lt;/item&gt;\n</code></pre> <pre><code>&lt;?php\n\nclass Foo\n{\n    public function bar()\n    {\n        // A magic getter method on the Magewire Service Provider\n        // lets you access the example feature facade.\n\n        $exampleFeatureFacade = $this-&gt;magewireServiceProvider\n            -&gt;getExampleFeatureFacade();\n    }\n}\n</code></pre>"},{"location":"pages/advanced/architecture/features.html","title":"Features","text":"<p>Livewire Concept</p> <p>Magewire is divided into three aspects. First, there is the architecture itself, which includes the module responsible for loading everything within Magento, as well as specific Livewire concepts. Those other two aspects within this architecture are Features and Mechanisms.</p> <p>In this documentation, we will focus specifically on Features.</p>"},{"location":"pages/advanced/architecture/features.html#concept","title":"Concept","text":"<p>The idea behind Features is that they are primarily optional and can be disabled without affecting the core principles of Magewire. In that sense, they are considered nice-to-haves.</p> <p>Any third-party additions to Magewire will mainly come in the form of Features and can be integrated separately through other modules.</p>"},{"location":"pages/advanced/architecture/features.html#example","title":"Example","text":"<p>We use Directives as an example.</p> <p>Magewire Directives allow you to add directives prefixed with <code>@</code> within Magewire-driven block templates. These directives use bound parsers to transform them into a specific output.</p> <p>For instance, consider <code>@ucfirst('foo')</code>, which would render as <code>Foo</code>.</p> <p>Now, you might wonder: If I disable this feature, won't <code>@ucfirst</code> just appear as plain text in my template? That\u2019s correct\u2014but it won\u2019t break the architecture, and everything else will continue to function as expected.</p> <p>So, while in this particular example, you would likely never want to disable or remove Directives, the possibility still exists.</p>"},{"location":"pages/advanced/architecture/features.html#write-your-own","title":"Write your own","text":"<p>To create and activate your own custom feature, you must inject it into the Features service type. This ensures it is properly executed within the system.</p> File: etc/frontend/di.xml<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:framework:ObjectManager/etc/config.xsd\"\n&gt;\n    &lt;type name=\"Magewirephp\\Magewire\\Features\"&gt;\n        &lt;arguments&gt;\n            &lt;!-- Option #1. --&gt;\n            &lt;argument name=\"items\" xsi:type=\"array\"&gt;\n                &lt;item name=\"magewire_compiling\" xsi:type=\"array\"&gt;\n                    &lt;item name=\"type\" xsi:type=\"string\"&gt;\n                        Magewirephp\\Magewire\\Features\\SupportMagewireCompiling\\SupportMagewireCompiling\n                    &lt;/item&gt;\n                    &lt;item name=\"sort_order\" xsi:type=\"number\"&gt;\n                        99100\n                    &lt;/item&gt;\n                &lt;/item&gt;\n            &lt;/argument&gt;\n\n            &lt;!-- Option #2. --&gt;\n            &lt;item name=\"magewire_compiling\" xsi:type=\"string\" sortOrder=\"99100\"&gt;\n                Magewirephp\\Magewire\\Features\\SupportMagewireCompiling\\SupportMagewireCompiling\n            &lt;/item&gt;\n        &lt;/arguments&gt;\n    &lt;/type&gt;\n&lt;/config&gt;\n</code></pre>"},{"location":"pages/advanced/architecture/features.html#module-structure","title":"Module structure","text":"<p>We encourage everyone to use the <code>src/</code> root folder within your module for all Magewire-related code. Components should reside directly in this folder or be organized into subdirectories. Features should also be placed within <code>src/</code>, using a <code>Features/</code> folder.</p> <p>Each feature should be grouped inside a <code>Support</code>-prefixed subfolder, which contains everything related to that feature.</p> <p>As a general rule within the core, feature naming follows a prefix convention:</p> <ul> <li>If it's a Magewire-specific feature, prefix it with <code>SupportMagewire</code>.</li> <li>If it's intended to make a Magento feature compatible with Magewire, use the <code>SupportMagento</code> prefix.</li> </ul> <p>This isn't a strict requirement, but it\u2019s considered a best practice for consistency.</p>"},{"location":"pages/advanced/architecture/features.html#javascript","title":"JavaScript","text":"<p>You can extend your feature to the frontend by adding JavaScript functionality when required.</p> <p>This JavaScript code doesn't live within the feature folder itself, but must be organized within the <code>/view</code> subfolder structure. For complete details on implementing JavaScript features, refer to the Features JavaScript paragraph.</p>"},{"location":"pages/advanced/architecture/features.html#hooks","title":"Hooks","text":"<p>The Livewire (and by extension, Magewire) architecture was designed with extensibility in mind, allowing developers to hook into certain processes before or after they occur.</p> <p>A general rule applies:</p> <ul> <li>Hooks must always return either a callback (which serves as the method to be executed after the process completes) or the original result from the hook.</li> <li>When using a callback, the result is automatically injected as an argument, allowing you to modify it if needed. However, you must always return the same result from the callback to maintain consistency.</li> </ul>"},{"location":"pages/advanced/architecture/features.html#faq","title":"FAQ","text":"Question Answer When do I use hooks? Only hook into specific Magewire processes or trigger your own events in areas of your code where you need to listen for them elsewhere. Are these hooks the same as Observer Events? No, the goal is to eventually provide developers with the ability to listen for events using standard observer events. While this is still an idea, we hope to implement it in the future to align more closely with Magento's principles. In the meantime, we recommend following the approach suggested by Livewire."},{"location":"pages/advanced/architecture/features.html#example_1","title":"Example","text":"Magewire/Features/SupportExample<pre><code>&lt;?php\n\nuse function Magewirephp\\Magewire\\on;\n\nclass SupportExample extends \\Magewirephp\\Magewire\\ComponentHook\n{\n    on('magewire:construct', function () {\n        // Before\n\n        return function (AbstractBlock $block) {\n\n            // After\n            return $block;\n        };\n    });\n}\n</code></pre> <p>The above example is triggered in the core using <code>$construct = trigger('magewire:construct', $block)</code>, where the result is assigned to a variable. The event listener receives the $block, but instead of directly returning it, it returns a callback that also accepts the <code>$block</code> argument. This callback is then triggered later in the code with <code>$construct()</code>.</p>"},{"location":"pages/advanced/architecture/layout.html","title":"Layout","text":"<p>Magewire is a large framework with many options and features. Still, we aim to keep things as flexible as possible, providing an easy way to inject additional JavaScript, UI components, and other frontend-related elements that Magewire needs.</p> <p>It's impossible to explain everything, and many parts are self-explanatory or include clear comments in the layout files to indicate their purpose.</p> <p>That said, we do want to document the most important containers and blocks to make things even clearer for those looking for specific situations or guidance on where to place blocks.</p>"},{"location":"pages/advanced/architecture/layout.html#containers","title":"Containers","text":"<p>Magewire provides a carefully structured layout to keep things organized and clear. It includes dedicated containers for everything related to Magewire, such as storing AlpineJS components, injecting custom feature-specific JavaScript, or adding custom directives.</p> Container Description magewire.before Container for elements that should precede all Magewire-related containers and blocks magewire.before.internal Magewire-only: Container for Magewire-specific logic that must load before internal Magewire elements are initialized magewire.internal Magewire-only: Contains non-overridable internal code magewire.after.internal Magewire-only: Container for Magewire-specific logic that must load after internal Magewire elements are initialized magewire.after Container for elements that should follow all Magewire-related containers and blocks magewire.alpinejs.before Contains custom AlpineJS code that must execute before Magewire-specific AlpineJS logic magewire.alpinejs.after Contains custom AlpineJS code that must render after Magewire-related AlpineJS code magewire.alpinejs.components Contains AlpineJS components specific to Magewire functionality magewire.alpinejs.directives Contains custom AlpineJS directives magewire.ui-components Contains custom AlpineJS UI components magewire.utilities Contains Magewire utilities magewire.addons Contains Magewire addons magewire.directives Contains Magewire directives magewire.features Contains Magewire features magewire.disabled Container for rendering elements only when Magewire is not active on the page"},{"location":"pages/advanced/architecture/layout.html#directories-templates","title":"Directories &amp; Templates","text":"<p>Magewire got a complete overhaul of its folder structure that has been well thought through in terms of simplicity and structuring things in a loosely coupled way.</p>"},{"location":"pages/advanced/architecture/layout.html#basics","title":"Basics","text":"<p>When you look in the core module <code>src/view/base</code> area templates directory, you'll find two folders: <code>js</code> and <code>magewire</code>. The first holds only templates with primarily <code>&lt;script&gt;</code> elements including mainly JavaScript, ordered in subdirectories according to their targeted library. So for example, everything Alpine related, even if it is for Magewire, should go into the <code>alpinejs</code> directory.</p> <p>One exception is that there can sometimes be files that don't have any JavaScript content in them, but are empowering child blocks by, for instance, making sure they are rendered.</p> <p>One example of this can be found at: <code>src/view/base/templates/js/alpinejs/component/magewire-notifier.phtml</code>.</p>"},{"location":"pages/advanced/architecture/layout.html#directories","title":"Directories","text":"Directory Description js/*/` Contains templates with primarily JavaScript content js/alpinejs/*/ Contains templates with AlpineJS-related JavaScript js/alpinejs/components/*/ Contains AlpineJS components only js/alpinejs/directives/*/ Contains AlpineJS directives only js/magewire/*/ Contains templates with Magewire-related JavaScript js/magewire/utils/*/ Contains Magewire utilities only js/magewire/addons/*/ Contains Magewire addons only js/magewire/directives/*/ Contains Magewire directives only js/magewire/features/*/ Contains JavaScript for Magewire Feature support, always divided with a lower-kebab-cased subfolder. <p>Building something custom or making a contribution? Always examine the folder and file structure closely to ensure you're in the right location.</p>"},{"location":"pages/advanced/architecture/portman.html","title":"Portman","text":"<p>Portman is solely needed for development and contributions. Magewire itself runs seamlessly without requiring Portman.</p> <p>Portman, developed by Justin van Elst, is a command-line utility designed to simplify the process of porting PHP libraries between frameworks.</p>"},{"location":"pages/advanced/architecture/portman.html#what-is-portman","title":"What is Portman?","text":"<p>The idea for Portman was born during a two-hour car ride, sparked by a discussion between Justin van Elst and Willem Poortman, about some ideal solutions to avoid the challenges faced during the development of the Magewire 3 port from Livewire. Throughout the process, a number of workarounds had to be implemented to make things function \u2014 many of which were less than ideal \u2014 as Livewire wasn\u2019t built with cross-framework compatibility in mind.</p> <p>During that conversation, a rough sketch of a possible solution was made. Justin took that concept and turned it into Portman \u2014 one of the most critical tools that made Magewire V3 possible.</p> <p>Portman enables developers to perform various porting tasks without the need to overwrite original source files. Since Magewire draws heavy inspiration from Livewire\u2019s codebase, keeping up with upstream changes would have been nearly impossible through manual syncing alone. Thanks to Portman\u2019s intelligent porting capabilities, only minimal modifications were needed to adapt Livewire\u2019s functionality for Magento.</p> <p>More details, please refer to the GitHub repository.</p>"},{"location":"pages/advanced/architecture/portman.html#requirements","title":"Requirements","text":"<p>Before we start, make sure you have the following installed:</p> <ul> <li>PHP version 8.2 or later</li> </ul>"},{"location":"pages/advanced/architecture/portman.html#installation","title":"Installation","text":"<p>To start contributing to Magewire, follow these steps:</p> <ol> <li>Require Portman via Composer:    <pre><code>composer require magewirephp/portman --dev\n</code></pre></li> <li>CD into the Magewirephp module:    <pre><code>cd vendor/magewirephp/magewire\n</code></pre></li> <li>Optionally, initialize a configuration when it does not exist:    <pre><code>../../bin/portman init\n</code></pre></li> <li>Optionally, download the donor source    <pre><code>../../bin/portman download-source\n</code></pre></li> <li>Build a new distribution:    <pre><code>../../bin/portman build\n</code></pre></li> <li>Optionally, use a watcher while programming:    <pre><code>../../bin/portman watch\n</code></pre></li> </ol>"},{"location":"pages/advanced/architecture/portman.html#watcher","title":"Watcher","text":"<p>The watcher will automatically trace files and rebuild a new distribution on file changes.</p> <ol> <li>Install <code>chokidar-cli</code>:    <pre><code>npm install chokidar-cli\n</code></pre></li> <li>Optionally, install it globally:    <pre><code>npm install chokidar-cli -g\n</code></pre></li> <li>Run the watcher:    <pre><code>../../bin/portman watch\n</code></pre></li> </ol>"},{"location":"pages/advanced/architecture/portman.html#troubleshooting","title":"Troubleshooting","text":"<p>Some common issues are:</p> Issue Solution The <code>/dist</code> folder is missing after requiring Magewire via Composer The distribution is only build when a new release is being pushed. When you require Magewire manually, you need to first build a new distribution. Disctribution build, but shows a warning that one or more files have a augmentation but no source. Use <code>../../bin/portman download-source</code> and rebuild once more."},{"location":"pages/advanced/architecture/mechanisms/index.html","title":"Mechanisms","text":"<p>Livewire Concept</p> <p>Magewire is divided into three aspects. First, there is the architecture itself, which includes the module responsible for loading everything within Magento, as well as specific Livewire concepts. Those other two aspects within this architecture are Features and Mechanisms.</p> <p>In this documentation, we will focus specifically on Mechanisms.</p>"},{"location":"pages/advanced/architecture/mechanisms/index.html#concept","title":"Concept","text":"<p>The idea behind Mechanisms is that they are essential components required for Magewire to function. They form a foundational part of the architecture and cannot be removed or treated as optional.</p> <p>As such, Mechanisms are typically core elements of Magewire, rather than being designed for injection or replacement through third-party extensions.</p>"},{"location":"pages/advanced/architecture/mechanisms/index.html#example","title":"Example","text":"<p>We use Resolvers as an example.</p> <p>Magewire Resolvers are critical components responsible for binding Magewire objects to blocks, effectively transforming them into Magewire components.</p> <p>Removing Resolvers would constitute a breaking change, as blocks intended to function as Magewire components would no longer be able to do so.</p> File: etc/frontend/di.xml<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:framework:ObjectManager/etc/config.xsd\"\n&gt;\n    &lt;type name=\"Magewirephp\\Magewire\\Mechanisms\"&gt;\n        &lt;arguments&gt;\n            &lt;!-- Option #1. --&gt;\n            &lt;argument name=\"items\" xsi:type=\"array\"&gt;\n                &lt;item name=\"resolve_components\" xsi:type=\"array\"&gt;\n                    &lt;item name=\"type\" xsi:type=\"string\"&gt;\n                        Magewirephp\\Magewire\\Mechanisms\\ResolveComponents\\ResolveComponents\n                    &lt;/item&gt;\n\n                    &lt;!-- Optional. --&gt;\n                    &lt;item name=\"sort_order\" xsi:type=\"number\"&gt;\n                        1000\n                    &lt;/item&gt;\n                    &lt;item name=\"view_model\" xsi:type=\"object\"&gt;\n                        Magewirephp\\Magewire\\Mechanisms\\ResolveComponents\\ResolveComponentsViewModel\n                    &lt;/item&gt;\n                &lt;/item&gt;\n            &lt;/argument&gt;\n\n            &lt;!-- Option #2. --&gt;\n            &lt;item name=\"resolve_components\" xsi:type=\"string\" sortOrder=\"1000\"&gt;\n                Magewirephp\\Magewire\\Mechanisms\\ResolveComponents\\ResolveComponents\n            &lt;/item&gt;\n        &lt;/arguments&gt;\n    &lt;/type&gt;\n&lt;/config&gt;\n</code></pre>"},{"location":"pages/advanced/architecture/mechanisms/index.html#mechanisms_1","title":"Mechanisms","text":"<p>The following mechanisms form the backbone of Magewire and are essential to its operation.</p> Name Description Sort Order Frontend Assets WIP 1400 Handle Components WIP 1100 Handle Requests WIP 1200 Resolver Components WIP 1000 Persist Middleware WIP 1050 Data Store WIP 1250 <p>While Livewire contains various Laravel-specific mechanisms, these are present in the source code but remain unused in the context of Magewire.</p>"},{"location":"pages/advanced/architecture/mechanisms/resolvers.html","title":"Resolvers","text":"<p>Magewire specific (since: 3.0.0)</p> <p>Component Resolvers are responsible for constructing a valid block having a Magewire argument\u2014essentially, a data <code>object</code> element that represents a Magewire Component.</p> <p>By default, thanks to Layout XML, blocks are automatically generated, and when a Magewire argument is added, the block is dynamically transformed. While this appears seamless, behind the scenes, the Layout Component Resolver is actually handling the process.</p> <p>However, in many other cases\u2014such as with Magento Widgets\u2014the standard layout approach doesn\u2019t apply. In these scenarios, the block must receive its Magewire argument differently and mount the component in an alternative way.</p> <p>The Resolver mechanism (or API) provides the flexibility to handle these cases.</p>"},{"location":"pages/advanced/architecture/mechanisms/resolvers.html#responsibilities","title":"Responsibilities","text":"<p>In all default Layout XML scenarios, no resolver needs to be added unless a specific case requires behavior different from the standard layout resolver. For most other scenarios, the package will either provide a suitable resolver out of the box, or a custom one will need to be written.</p> <p>At its core, a component resolver is responsible for the following:</p> <ol> <li>Verifying block compliance \u2013 Determines whether a block meets the required conditions to be used as a component resolver (method: <code>complies</code>).</li> <li>Constructing the component on page load (method: <code>construct</code>). </li> <li>Reconstructing the component during a subsequent (XHR) request (method: <code>reconstruct</code>). </li> <li>Providing the lifecycle with an arguments object (method: <code>arguments</code>).</li> </ol> <p>Additional methods exist within the abstraction but are optional, depending on the use case.</p>"},{"location":"pages/advanced/architecture/mechanisms/resolvers.html#lifecycle","title":"Lifecycle","text":"<p>Behind the scenes, Magewire checks every block that attempts to render itself to see if it contains a <code>magewire</code> data element. If it does, regardless of its value, the Magewire lifecycle will automatically attempt to construct it.</p> <p>At this point, the block is passed through the <code>complies</code> method to determine whether it belongs to your custom resolver.</p> <p>If all conditions are met, that resolver will be used to construct the block and reconstruct it when a subsequent request is triggered on the frontend.</p> <p>Thanks to the <code>remember</code> method returning <code>true</code>, a cache if being applied, preventing the need to repeatedly check whether it meets the resolver\u2019s requirements.</p>"},{"location":"pages/advanced/architecture/mechanisms/resolvers.html#example","title":"Example","text":"<p>creating a custom resolver is intended for more advanced Magewire developers who have a solid understanding of the Magewire lifecycle and how to connect various pieces of data effectively.</p> <p>A resolver is essentially a single class that extends the resolver abstraction and implements a few required methods to determine whether it applies to a given block.</p> <p>Because Magento works primarily with blocks, it will be most likely your custom resolver will extend from the <code>layout</code> resolver.</p> <pre><code>&lt;?php\n\ndeclare(strict_types=1);\n\nnamespace Example\\Module\\Mechanisms\\ResolveComponents\\ComponentResolver;\n\nuse \\Magewirephp\\Magewire\\Mechanisms\\ResolveComponents\\ComponentResolver\\ComponentResolver\\LayoutResolver\n\nclass ExampleResolver extends LayoutResolver\n{\n    protected string $accessor = 'example';\n\n    // A lightweight check to determine if the given block meets the requirements \n    // to be resolved using this resolver.\n    public function complies(AbstractBlock $block, mixed $magewire = null): bool\n    {\n        return $block-&gt;hasData('foo') &amp;&amp; $block-&gt;getData('foo') === 'bar';\n    }\n\n    // Constructs a block, initializes a Magewire component object, and sets its ID and name.\n    public function construct(AbstractBlock $block): AbstractBlock\n    {\n        $block-&gt;setData('magewire') = $myCustomComponentFactory-&gt;create($block)\n\n        return parent::construct($block);\n    }\n\n    // Reconstructing the block from the given snapshot during an update request cycle.\n    public function reconstruct(\\Magewirephp\\Magewire\\Mechanisms\\HandleRequests\\ComponentRequestContext $request): AbstractBlock\n    {\n        $snapshot = $request-&gt;getSnapshot();\n\n        return parent::reconstruct($request);\n    }\n}\n</code></pre> <p>Finally, make the resolver accessible through the Component Resolver Management by configuring it in <code>di.xml</code>.</p> File: etc/frontend/di.xml<pre><code>&lt;type name=\"Magewirephp\\Magewire\\Mechanisms\\ResolveComponents\\ComponentResolverManagement\"&gt;\n    &lt;arguments&gt;\n        &lt;argument name=\"resolvers\" xsi:type=\"array\"&gt;\n\n            &lt;!-- The sort order defines which resolver is evaluated first and should always be set. --&gt;\n            &lt;item name=\"layout\" xsi:type=\"object\" sortOrder=\"1337\"&gt;\n                Magewirephp\\Magewire\\Mechanisms\\ResolveComponents\\ComponentResolver\\LayoutResolver\n            &lt;/item&gt;\n        &lt;/argument&gt;\n    &lt;/arguments&gt;\n&lt;/type&gt;\n</code></pre>"},{"location":"pages/advanced/javascript/index.html","title":"JavaScript","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/advanced/javascript/index.html#features","title":"Features","text":"<p>The Features area is an extension of the Features architectural page and the main Features list.</p> <p>Within the codebase, all supporting JavaScript belonging to a Feature must be organized within the /view folder to enable proper loading. This organizational requirement is why this section is documented under the JavaScript heading.</p> <p>When you require JavaScript for a feature you're developing, you must use a related folder structure inside <code>/view/{area}/js/magewire/features/</code>, followed by a phtml file that matches the feature folder name.</p> <p>This approach ensures the JavaScript is wrapped within a dedicated folder, providing a logical place for additional support files. While this structure may seem excessive at first glance, it becomes invaluable as soon as you need to include additional files or resources.</p> <p>You can register a feature using the following layout XML configuration:</p> view/{area}/layout/default.xml<pre><code>&lt;referenceContainer name=\"magewire.features\"&gt;\n    &lt;block name=\"magewire.features.support-magewire-loaders\"\n           template=\"Magewirephp_Magewire::js/magewire/features/support-magewire-loaders/support-magewire-loaders.phtml\"\n    /&gt;\n&lt;/referenceContainer&gt;\n</code></pre> <p>The corresponding PHTML file contains the JavaScript implementation without specific rules or limitations.</p> <p>In the example below, the code listens for Magewire initialization and registers a commit hook that executes business logic whenever an XHR commit is triggered:</p> <pre><code>&lt;script&gt;\n    document.addEventListener('magewire:init', event =&gt; {\n        const { addons, utilities } = event.detail.magewire;\n\n        Magewire.hook('commit', ({ component, commit, respond, succeed, fail }) =&gt; {\n            ...\n        });\n    });\n&lt;/script&gt;\n</code></pre> <p>The PHTML content can implement any JavaScript functionality required for your feature. The framework provides complete flexibility in what you can accomplish within this structure.</p>"},{"location":"pages/advanced/javascript/index.html#addons","title":"Addons","text":"<p>In addition to the core library, Magewire provides an <code>addons</code> object as a centralized place to store custom functionality\u2014avoiding the need to attach them to the global (and often cluttered) <code>window</code> object.</p> <p>You can register an addon like this:</p> view/{area}/layout/default.xml<pre><code>&lt;referenceContainer name=\"magewire.addons\"&gt;\n    &lt;block name=\"magewire.addons.notifier\"\n           template=\"Example_Module::view/frontend/templates/js/magewire/addons/notifier.phtml\"\n    /&gt;\n&lt;/referenceContainer&gt;\n</code></pre> <p>And define the addon itself with the following code:</p> <pre><code>&lt;script&gt;\n    function magewireNotifierAddon() {\n        'use strict';\n\n        return {\n            notifications: [],\n\n            create(text) {\n                this.notifications.push({text: text});\n            }\n        }\n    }\n\n    document.addEventListener('magewire:init', () =&gt; Magewire.addon('notifier', magewireNotifierAddon, true), { once: true });\n&lt;/script&gt;\n</code></pre> <p>Reactivity</p> <p>The third argument, <code>reactive</code>, allows developers to make the addon reactive using <code>Alpine.reactive()</code>. This is useful if you want to expose your addon as an Alpine component with a globally accessible <code>notifications</code> array, while still being able to leverage features like <code>this.$watch('notifications', (current, previous) =&gt; {})</code> change tracking.</p>"},{"location":"pages/advanced/javascript/index.html#alpine-components","title":"Alpine components","text":"<p>To make your addon available as an Alpine component where <code>notifications</code> are globally accessible, you\u2019ll want to ensure that other Alpine components can inject <code>notifications</code> into it\u2014without introducing conflicts or requiring multiple, isolated notifications arrays in the DOM.</p> <p>You can register your AlpineJS component like this:</p> view/frontend/layout/default.xml<pre><code>&lt;referenceContainer name=\"magewire.alpinejs.components\"&gt;\n    &lt;block name=\"magewire.alpinejs.components.magewire-notifier\"\n           template=\"Example_Module::js/alpinejs/magewire-notifier.phtml\"\n    /&gt;\n&lt;/referenceContainer&gt;\n</code></pre> <p>And then define the corresponding Alpine component as follows:</p> <pre><code>&lt;script&gt;\n    document.addEventListener('alpine:init', () =&gt; {\n        Alpine.data('magewireNotifier', () =&gt; ({\n            ...Magewire.addons.notifier, ...{\n                get notifications() {\n                    return Magewire.addons.notifier.notifications;\n                }\n            }\n        }));\n    });\n&lt;/script&gt;\n</code></pre> <p>In this case, we create a getter for the <code>notifications</code>, allowing us to expose the notifier\u2019s internal notification array in a way that's usable in your HTML\u2014such as with <code>&lt;template x-for=\"notification in notifications\"&gt;</code>.</p> Caveats When Sharing Objects Between <code>Alpine.store()</code> and <code>Alpine.data()</code> <p>AlpineJS allows you to define global state using <code>Alpine.store()</code> or <code>this.$store()</code>, depending on context. Objects stored this way are automatically made reactive via <code>Alpine.reactive()</code> under the hood.</p> <p>However, there's a caveat: if the stored object includes an <code>init</code> method, Alpine will automatically invoke it upon storing.</p> <p>Later, if you use that same object in a component via <code>Alpine.data()</code>, the init method will be triggered again, since <code>Alpine.data()</code> also auto-invokes init. This behavior can lead to unintended side effects, requiring you to be cautious\u2014if the object has an <code>init</code> method, you may need to override it with an empty function to avoid double execution.</p>"},{"location":"pages/advanced/javascript/index.html#utilities","title":"Utilities","text":"<p>In addition to the core library, Magewire provides a <code>utilities</code> object as a centralized place to store custom support functionality that can be useful throughout the framework \u2014 such as splitting strings, validating objects, extracting attributes from DOM elements, and more.</p> <p>These utilities serve as general-purpose helpers, whereas addons are more specialized and should be thought of as APIs.</p> <p>You can register a utility like this:</p> view/frontend/layout/default.xml<pre><code>&lt;referenceContainer name=\"magewire.utilities\"&gt;\n    &lt;block name=\"magewire.utilities.notifier\"\n           template=\"Example_Module::view/frontend/templates/js/magewire/utils/dom.phtml\"\n    /&gt;\n&lt;/referenceContainer&gt;\n</code></pre> <p>And you can define the utility itself using the following code:</p> <pre><code>&lt;script&gt;\n    function magewireDomUtility() {\n        'use strict';\n\n        return {\n            filterDataAttributes: function (element, prefix = '') {\n                return {};\n            }\n        }\n    }\n\n    document.addEventListener('magewire:init', () =&gt; Magewire.utility('dom', magewireDomUtility));\n&lt;/script&gt;\n</code></pre> <p>Magewire utilities are stored in the <code>/utils</code> directory, rather than in a folder named <code>/utilities</code>.</p>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html","title":"Magewire Notifier","text":"<p>Notification management for displaying user messages.</p> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    const { addons } = event.detail.magewire;\n    const message = 'Foo';\n\n    addons.notifier.create(message, { duration: 50000 }, {\n        onActivate: notification =&gt; console.log('Notification activated.')\n    }).then(notification =&gt; {\n        console.log('Notification created.')\n    }).catch(exception =&gt; {\n        console.log('Notification', message)\n    })\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#elements","title":"Elements","text":"Description File Magewire Addon view/base/templates/js/magewire/addons/notifier.phtml Alpine Component view/base/templates/js/alpinejs/components/magewire-notifier.phtml UI Component view/base/templates/magewire/ui-components/notifier.phtml"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#methods","title":"Methods","text":""},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#async-create","title":"<code>async create</code>","text":"<p>Create a new notification and optionally activate it immediately.</p> <p>Arguments:</p> <ul> <li><code>message</code> (string) - The message content to display in the notification.</li> <li><code>options</code> (object, optional) - Configuration options for the notification:<ul> <li><code>type</code> (string, optional) - Notification type: <code>'success'</code>, <code>'error'</code>, <code>'warning'</code>, <code>'info'</code>. Default: <code>'info'</code>.</li> <li><code>title</code> (string, optional) - Notification title. Default: <code>'Message Unknown'</code> (i18n).</li> <li><code>duration</code> (number, optional) - Display duration in milliseconds. Default: <code>3600</code>.</li> <li><code>recoverable</code> (bool, optional) - Can be recovered and will trigger the <code>onRecover</code> hook.</li> </ul> </li> <li><code>hooks</code> (object, optional) - Event callback functions that will be triggered during the notification lifecycle:<ul> <li><code>onActivate({ notification })</code> (function, optional) - Called when notification is activated.</li> <li><code>onCleanup({ notification })</code> (function, optional) - Called during cleanup process.</li> <li><code>onTermination({ notification })</code> (function, optional) - Called when notification is terminated.</li> <li><code>onRecover({ notification })</code> (function, optional) - Called when notification encounters an error.</li> <li><code>onStateChange({ notification })</code> (function, optional) - Called when notification encounters an error.</li> <li><code>onFailure({ notification, reason })</code> (function, optional) - Called when notification encounters an error.</li> </ul> </li> <li><code>activate</code> (boolean, optional) - Whether to automatically activate the notification upon creation. Default: <code>true</code>.</li> </ul> <p>Returns: <code>Promise&lt;Notification&gt;</code></p> <pre><code>document.addEventListener('magewire:init', async event =&gt; {\n    const notification = await create(\n        // Message\n        'Task completed successfully',\n\n        // Options\n        { type: 'success', duration: 5000 },\n\n        // Hooks\n        { onFinish: notification =&gt; console.log('Done!') },\n\n        // Activate\n        true\n    );\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#get","title":"<code>get</code>","text":"<p>Returns a notification.</p> <p>Arguments:</p> <ul> <li><code>id</code> (number) - Notification ID.</li> </ul> <p>Returns: <code>object&lt;Notification&gt;|null</code></p> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    const notification = Magewire.addons.notifier.get(1);\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#async-activate","title":"<code>async activate</code>","text":"<p>Activates a notification.</p> <p>Arguments:</p> <ul> <li><code>id</code> (number) - Notification ID.</li> </ul> <p>Returns: <code>Promise&lt;Notification&gt;</code></p> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    Magewire.addons.notifier.activate(1);\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#async-finish","title":"<code>async finish</code>","text":"<p>Flags a notification as finished.</p> <p>For example after a loading process has completed.</p> <p>Arguments:</p> <ul> <li><code>id</code> (number) - Notification ID.</li> </ul> <p>Returns: <code>Promise&lt;Notification&gt;</code></p> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    Magewire.addons.notifier.finish(1);\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#async-terminate","title":"<code>async terminate</code>","text":"<p>Flags a notification as terminated, making it inactive.</p> <p>Arguments:</p> <ul> <li><code>id</code> (number) - Notification ID.</li> </ul> <p>Returns: <code>Promise&lt;Notification&gt;</code></p> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    Magewire.addons.notifier.terminate(1);\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#async-fail","title":"<code>async fail</code>","text":"<p>Flags a notification as failed.</p> <p>Arguments:</p> <ul> <li><code>id</code> (number) - Notification ID</li> <li><code>reason</code> (string, optional) - Failure reason. Default: <code>null</code></li> </ul> <p>Returns: <code>Promise&lt;Notification&gt;</code></p> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    Magewire.addons.notifier.fail(1);\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#async-hold","title":"<code>async hold</code>","text":"<p>Clears the active notification timeout.</p> <p>Arguments:</p> <ul> <li><code>id</code> (number) - Notification ID</li> </ul> <p>Returns: <code>Promise&lt;Notification&gt;</code></p> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    Magewire.addons.notifier.hold(1);\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#async-fetch","title":"<code>async fetch</code>","text":"<p>Returns all notifications.</p> <p>Returns: <code>Array&lt;int, Notification&gt;</code></p> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    const notifications = Magewire.addons.notifier.fetch();\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#async-trigger","title":"<code>async trigger</code>","text":"<p>Triggers hooks on a global and an item level when available.</p> <p>Arguments:</p> <ul> <li><code>hook</code> (string) - Hook name</li> <li><code>args</code> (object, optional) - Hook arguments. Default: <code>{}</code></li> <li><code>notification</code> (object, optional) - Existing notification object. Default: <code>null</code></li> </ul> <pre><code>document.addEventListener('magewire:init', event =&gt; {\n    Magewire.addons.notifier.trigger('foo', { bar: 'baz' }, null);\n})\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#events","title":"Events","text":"<p>Hooking into several notifier events can be achieved like so:</p> <pre><code>document.addEventListener('magewire:init', () =&gt; {\n    Magewire.hook('addons.notifier.state-change', ({ state, previous, notification }) =&gt; {\n        console.log(`Notification state changed from ${state} to ${previous}`, notification);\n    });\n});\n</code></pre>"},{"location":"pages/advanced/javascript/addons/magewire-notifier.html#available-events","title":"Available Events","text":"Event Arguments addons.notifier.activate <code>{ notification }</code> addons.notifier.cleanup <code>{ notification }</code> addons.notifier.terminate <code>{ notification }</code> addons.notifier.recover <code>{ notification }</code> addons.notifier.state-change <code>{ state, previous, notification }</code> addons.notifier.failure <code>{ notification, reason }</code> <p>Use <code>Magewire.addons.notifier.create()</code> to define notification-specific hooks for individual notifications. Use global hooks to respond to lifecycle events across all notifications.</p>"},{"location":"pages/advanced/javascript/features/magewire-loaders.html","title":"Magewire Loaders","text":"<p>Magewire loaders have been a core feature since V1 and have been reintroduced and fully rewritten in V3. With the much more advanced JavaScript layer behind Magewire, the options to do it the right way was one we could let go by.</p>"},{"location":"pages/advanced/javascript/features/magewire-loaders.html#class-properties","title":"Class Properties","text":"<p>Loaders can be implemented in multiple ways. Using the protected <code>$loader</code> property allows you to display a notification with a loading SVG (spinner by default) that appears only while the network processes the update request.</p> <p>In the following example, a \"Processing...\" notification is shown to the user when an increment update request is being executed:</p> File: Magewire/Counter.php<pre><code>&lt;?php\n\nnamespace Vendor\\Module\\Magewire;\n\nclass Counter extends \\Magewirephp\\Magewire\\Component\n{\n    public int $count = 0;\n\n    protected $loader = ['increment' =&gt; 'Processing...'];\n\n    public function increment(): void\n    {\n        $this-&gt;count++;\n    }\n}\n</code></pre>"},{"location":"pages/advanced/javascript/features/magewire-loaders.html#patterns","title":"Patterns","text":"<p>Since V3, the available options have increased, supporting different patterns such as showing additional notifications when requests complete.</p> <p>These are divided into two sections: method calls and property update requests.</p>"},{"location":"pages/advanced/javascript/features/magewire-loaders.html#method-calls","title":"Method Calls","text":"Pattern Description Since <code>['{method}' =&gt; 'Loading']</code> Regular method call 1.0.0 <code>['{method}' =&gt; 'Loading ... Loaded']</code> Regular method call, followed by a processed notification 3.0.0 <p>WIP: more to follow soon</p>"},{"location":"pages/advanced/javascript/features/magewire-loaders.html#property-update-requests","title":"Property Update Requests","text":"Pattern Description Since <code>['{property}' =&gt; 'Updating property']</code> When a property update is behind handled 3.0.0 <p>WIP: more to follow soon</p>"},{"location":"pages/advanced/javascript/features/magewire-loaders.html#hooks","title":"Hooks","text":"<p>Combining regular Magewire JavaScript hooks with the Magewire Notifier addon allows you to display custom messages. However, this approach can be complex due to the variety of update types and method calls.</p> <p>We want to demonstrate this capability as inspiration for alternative implementations when needed.</p> <pre><code>&lt;script&gt;\n    document.addEventListener('magewire:init', event =&gt; {\n        const { addons, utilities } = event.detail.magewire;\n\n        Magewire.hook('commit', ({ component, commit, respond, succeed, fail }) =&gt; {\n            addons.notifier.create('Committed');\n\n            succeed(({ snapshot, effect }) =&gt; addons.notifier.create('Succeeded'));\n        });\n    });\n&lt;/script&gt;\n</code></pre>"},{"location":"pages/advanced/javascript/utilities/dom.html","title":"Dom","text":"<p>WIP...</p>"},{"location":"pages/advanced/javascript/utilities/loader.html","title":"Loader","text":"<p>WIP...</p>"},{"location":"pages/advanced/javascript/utilities/str.html","title":"Str","text":"<p>WIP...</p>"},{"location":"pages/concepts/fragments.html","title":"Fragments","text":"<p>Fragments can also be used outside Magewire components!</p> <p>Magewire includes a built-in implementation to support features such as Content Security Policy (CSP) compliance out of the box. One key feature in this implementation is the use of Fragments and Fragment Modifiers.</p> <p>Fragments are explicitly defined sections of code, marked by a developer using a <code>start()</code> and <code>end()</code> method.</p>"},{"location":"pages/concepts/fragments.html#defining-a-fragment","title":"Defining a Fragment","text":"<p>Defining a fragment in your template is straightforward using the Magewire ViewModel's template utilities. In the example below, we're creating a <code>script</code> fragment.</p> <p>This fragment comes with a built-in CSP modifier. When rendered on a full-page cached page, a hash will be automatically added to the dynamic CSP collection.</p> <p>If the page is not cached, a nonce will be injected into the <code>&lt;script&gt;</code> tag instead.</p> <pre><code>&lt;?php\n\n$magewireViewModel = $block-&gt;getData('view_model');\n$fragment = $magewireViewModel-&gt;utils()-&gt;template()-&gt;fragment();\n?&gt;\n\n&lt;?php $script = $fragment-&gt;script()-&gt;start() ?&gt;\n&lt;script&gt;\n    console.log('Custom Fragment');\n&lt;/script&gt;\n&lt;?php $script-&gt;end() ?&gt;\n</code></pre> <p>Fragment Modifiers</p> <p>Each fragment type can have its own modifiers, which are injected via <code>di.xml</code>. You can inject custom logic by specifying a class that implements <code>Magewirephp\\Magewire\\Model\\View\\Fragment\\Modifier</code> in the <code>modifiers</code> array of the constructor.</p>"},{"location":"pages/concepts/fragments.html#script-fragment","title":"Script Fragment","text":"<p>To better illustrate how typed fragments work, let's examine the script fragment implementation. This fragment type requires validation, while any modifications are handled separately through modifiers.</p> <p>A fragment must extend <code>Magewirephp\\Magewire\\Model\\View\\Fragment</code>. You can create a fragment using the <code>Magewirephp\\Magewire\\Model\\View\\FragmentFactory</code> or via the Magewire ViewModel template utility with <code>$viewModel-&gt;utils()-&gt;template()-&gt;fragment()</code>.</p> Magewirephp\\Magewire\\Model\\View\\Fragment\\Script<pre><code>&lt;?php\n\nclass Script extends \\Magewirephp\\Magewire\\Model\\View\\Fragment\\Html\n{\n    public function start(): static\n    {\n        // ...\n    }\n\n    /**\n     * Returns the content between the script tags.\n     */\n    public function getScriptCode(): string\n    {\n        // ...\n    }\n}\n</code></pre>"},{"location":"pages/concepts/fragments.html#fragment-modifiers","title":"Fragment Modifiers","text":"<p>Each fragment instance can have its own modifier, which is responsible for adjusting or enhancing the final output. Modifiers allow you to apply logic such as injecting a CSP hash, adding attributes, or manipulating content dynamically.</p> <p>One important consideration when adding modifiers is the sort order. Modifiers are applied in sequence, so the order in which they are executed can significantly affect the final result.</p> <p>To inject custom modifiers into a fragment, use Magento\u2019s <code>di.xml</code> configuration.</p> <p>Here\u2019s a basic outline:</p> <pre><code>&lt;type name=\"Magewirephp\\Magewire\\Model\\View\\Fragment\\Script\"&gt;\n    &lt;arguments&gt;\n        &lt;argument name=\"modifiers\" xsi:type=\"array\"&gt;\n            &lt;!-- Maximum sort order to make sure this modifier is run last. --&gt;\n            &lt;item name=\"csp\" sortOrder=\"9999\" xsi:type=\"object\"&gt;\n                Magewirephp\\Magewire\\Model\\View\\Fragment\\Modifier\\Csp\n            &lt;/item&gt;\n        &lt;/argument&gt;\n    &lt;/arguments&gt;\n&lt;/type&gt;\n</code></pre> <p>A modifier has access to the raw fragment code. The CSP modifier either includes a hash of the inline JavaScript within the <code>&lt;script&gt;</code> tags or adds a <code>nonce=\"...\"</code> attribute to the script tag when the page is not cached.</p> Magewirephp\\Magewire\\Model\\View\\Fragment\\Modifier\\Csp<pre><code>&lt;?php\n\nclass Csp extends \\Magewirephp\\Magewire\\Model\\View\\Fragment\\Modifier\n{\n    public function modify(string $output, Fragment $fragment): string\n    {\n        if (! $fragment instanceof Fragment\\Script) {\n            return $output;\n        }\n\n        // ...\n\n        return $output;\n    }\n}\n</code></pre>"},{"location":"pages/concepts/fragments.html#wrapping-a-fragment","title":"Wrapping a Fragment","text":"<p>Imagine a situation in your PHP code where you already have HTML stored in a variable.</p> <p>In this case, using <code>start</code> and <code>stop</code> wouldn\u2019t make sense\u2014unless that HTML already contains or is a fragment.</p> <p>If it\u2019s not a fragment, you can simply use the wrap method instead. This method works like starting and stopping combined, and it supports all the same features such as modifiers and validators, but in a single call.</p> Vendor\\Module\\Model\\View\\Renderer<pre><code>&lt;?php\n\nclass Renderer\n{\n    public function __construct(\n        \\Magewirephp\\Magewire\\Model\\View\\FragmentFactory $fragmentFactory\n    ) {\n        //\n    }\n\n    public function render(string $html): string\n    { \n        return $this-&gt;fragmentFactory-&gt;html()-&gt;wrap($html); \n    }\n}\n</code></pre>"},{"location":"pages/concepts/hydration.html","title":"Hydration","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/concepts/morphing.html","title":"Morphing","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/concepts/nesting.html","title":"Nesting","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/essentials/actions.html","title":"Actions","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/essentials/components.html","title":"Components","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/essentials/components.html#creating-components","title":"Creating components","text":"<p>Creating a basic Magewire component takes just a few minutes and requires only two or three files, depending on whether you already have a layout handle. At its core, a Magewire component consists of two main files: a PHP class that handles the logic and a template responsible for rendering the HTML on the frontend.</p> <p>In the following example, we assume you are using layout XML to inject a Magewire component onto a page. For more advanced use cases, we recommend exploring the in-depth documentation, where concepts like the resolver mechanism will most likely play a role.</p>"},{"location":"pages/essentials/components.html#1-create-a-component-class","title":"1. Create a Component class","text":"<p>Create a new component class:</p> File: Magewire/Counter.php<pre><code>&lt;?php\n\nnamespace Vendor\\Module\\Magewire;\n\nclass Counter extends \\Magewirephp\\Magewire\\Component\n{\n    public int $count = 0;\n\n    public function increment(): void\n    {\n        $this-&gt;count++;\n    }\n}\n</code></pre> <p>Note: It is advisable to keep your components inside the <code>Magewire</code> root directory of your module, either as direct children or nested within subdirectories.</p>"},{"location":"pages/essentials/components.html#2-create-a-template-file","title":"2. Create a Template File","text":"<p>Now, create the corresponding template file:</p> File: view/frontend/templates/magewire/counter.phtml<pre><code>&lt;div&gt;\n    Counter: &lt;?= $magewire-&gt;count ?&gt;\n\n    &lt;button wire:click=\"increment\"&gt;\n        Increase\n    &lt;/button&gt;\n&lt;/div&gt;\n</code></pre> <p>Note: Every Magewire component binds its state to the first HTML element in its template. This means you must always wrap your component's content in a root HTML element, such as a <code>&lt;div&gt;</code>, to ensure proper functionality.</p>"},{"location":"pages/essentials/components.html#3-inject-onto-a-page","title":"3. Inject onto a page","text":"<p>To render the component, add the following to your layout handle:</p> File: view/frontend/layout/page_handle.xml<pre><code>&lt;referenceBlock name=\"content\"&gt;\n    &lt;block name=\"counter.block\" template=\"Vendor_Module::magewire/counter.phtml\"&gt;\n        &lt;arguments&gt;\n            &lt;argument name=\"magewire\" xsi:type=\"object\"&gt;\n                Vendor\\Module\\Magewire\\Counter\n            &lt;/argument&gt;\n        &lt;/arguments&gt;\n    &lt;/block&gt;\n&lt;/referenceBlock&gt;\n</code></pre> <p>Note: This is the standard method for injecting a Magewire component into your page. However, alternatives exist through component resolvers, allowing more flexible integration. You can even create a custom resolver to fit specific requirements.</p>"},{"location":"pages/essentials/components.html#4-test-it-out","title":"4. Test it out","text":"<p>Clear the Magento cache and navigate to the relevant page:</p> <pre><code>bin/magento cache:flush\n</code></pre>"},{"location":"pages/essentials/events.html","title":"Events","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/essentials/events.html#component-hooks","title":"Component Hooks","text":"<p>Magewire allows developers to register Component Hooks when creating new features.</p> <p>These hooks are simple classes with a <code>provide</code> method that carry listeners for various events and can act as middleware.</p>"},{"location":"pages/essentials/events.html#creating-a-component-hook","title":"Creating a Component Hook","text":"<p>Component hooks provide a powerful way to intercept and modify the behavior of Magewire components at different stages of their lifecycle.</p>"},{"location":"pages/essentials/events.html#basic-hook-structure","title":"Basic Hook Structure","text":"<pre><code>&lt;?php\n\nclass SupportExample extends \\Magewirephp\\Magewire\\ComponentHook\n{\n    // Very useful when building a feature.\n    public function provide(): void\n    {\n        \\Magewirephp\\Magewire\\on('render', function (Component $component, AbstractBlock $block) {\n            // Before rendering.\n\n            return function (string $html) {\n                return $html; // After rendering.\n            };\n        });\n    }\n}\n?&gt;\n</code></pre>"},{"location":"pages/essentials/events.html#hook-behavior","title":"Hook Behavior","text":"<p>Before: When no callback is returned, the hook acts as a \"before\" plugin.</p> <p>After: When returning a callback that accepts the returned arguments, it acts as an \"after\" plugin.</p>"},{"location":"pages/essentials/events.html#observer-events","title":"Observer Events","text":"<p>For developers familiar with Magento's observer pattern, Magewire provides an alternative approach using regular Observer Events. This method is ideal when you don't need to create a full-featured component hook.</p>"},{"location":"pages/essentials/events.html#event-configuration","title":"Event Configuration","text":"<p>Observer events work similarly to component hooks but use Magento's standard event system. A Data Transfer Object (DTO) is passed along, which allows you to register listener callbacks.</p> <p>All Magewire events are prefixed with <code>magewire_on_</code> followed by the event name.</p> etc/frontend/events.xml<pre><code>&lt;event name=\"magewire_on_render\"&gt;\n    &lt;observer name=\"MagewireOnRender\"\n              instance=\"Example\\Module\\Observer\\Frontend\\MagewireOnRender\"\n    /&gt;\n&lt;/event&gt;\n</code></pre> <p>Observer Implementation</p> <pre><code>&lt;?php\n\nclass MagewireOnRender implements \\Magento\\Framework\\Event\\ObserverInterface\n{\n    public function execute(\\Magento\\Framework\\Event\\Observer $observer): void\n    {\n        /** @var \\Magewirephp\\Magewire\\Features\\SupportMagentoObserverEvents\\DTO\\ListenerDataTransferObject $listener */\n        $listen = $observer-&gt;getData('listener');\n\n        $listen-&gt;with(function ($component, $block) {\n            // Before rendering.\n\n            return function (string $html) {\n                return $html; // After rendering.\n            };\n        });\n    }\n}\n?&gt;\n</code></pre>"},{"location":"pages/essentials/events.html#available-events","title":"Available Events","text":"<p>Event Source</p> <p>Most events are inherited from Livewire, with additional Magewire-specific events identifiable by the <code>magewire:</code> prefix.</p>"},{"location":"pages/essentials/events.html#page-request","title":"Page Request","text":"<p>Events that occur during initial page loads:</p> <ul> <li>magewire:construct</li> <li>pre-mount</li> <li>mount</li> <li>magewire:precompile</li> <li>magewire:compiled</li> <li>render</li> <li>dehydrate</li> <li>checksum.generate</li> <li>destroy</li> </ul>"},{"location":"pages/essentials/events.html#update-request","title":"Update Request","text":"<p>Events that occur during component updates (subsequent requests):</p> <ul> <li>checksum.verify</li> <li>checksum.generate</li> <li>snapshot.verified</li> <li>request</li> <li>magewire:reconstruct</li> <li>hydrate</li> <li>call</li> <li>magewire:precompile</li> <li>magewire:compiled</li> <li>render</li> <li>dehydrate</li> <li>checksum.generate</li> <li>destroy</li> <li>response</li> </ul>"},{"location":"pages/essentials/events.html#lifecycle","title":"Lifecycle","text":"<p>Core component lifecycle events:</p> <ul> <li>magewire:construct</li> <li>magewire:precompile</li> <li>magewire:compiled</li> <li> <p>magewire:reconstruct</p> </li> <li> <p>pre-mount</p> </li> <li>mount.stub</li> <li>mount</li> <li>hydrate</li> <li>update</li> <li>call</li> <li>render</li> <li>render.placeholder</li> <li>dehydrate</li> <li>destroy</li> </ul>"},{"location":"pages/essentials/events.html#request-response-cycle","title":"Request / Response cycle","text":"<ul> <li>request</li> <li>response</li> <li>magewire:response.render</li> </ul>"},{"location":"pages/essentials/events.html#checksum-operations","title":"Checksum operations","text":"<p>checksum.generate checksum.verify checksum.fail snapshot-verified</p>"},{"location":"pages/essentials/events.html#magic-methods","title":"Magic methods","text":"<ul> <li>__get</li> <li>__unset</li> <li>__call</li> </ul>"},{"location":"pages/essentials/events.html#utility-events","title":"Utility events","text":"<ul> <li>exception</li> <li>flush-state</li> <li>profile</li> </ul> <p>Event Name Conversion</p> <p>When using Magento Observer Events, special characters in event names are converted to underscores due to Magento's naming restrictions. For example, . becomes _ in the observer event name.</p>"},{"location":"pages/essentials/lifecycle-hooks.html","title":"Lifecycle Hooks","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/essentials/nesting-components.html","title":"Nesting Components","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/essentials/properties.html","title":"Properties","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/essentials/testing.html","title":"Testing","text":"<p>Magewire's test coverage is currently limited, focusing primarily on Playwright tests. We plan to expand testing in the future to include unit tests and other test types as needed.</p>"},{"location":"pages/essentials/testing.html#playwright","title":"Playwright","text":"<p>Playwright is an open-source automation library developed by Microsoft for testing and automating web applications. It enables developers to write reliable end-to-end tests by simulating user interactions across multiple browsers, including Chromium, Firefox, and WebKit. Playwright supports various programming languages like JavaScript, TypeScript, Python, and C#, and provides features such as auto-waiting, network interception, and mobile emulation. It is widely used for ensuring web application functionality and performance.</p>"},{"location":"pages/essentials/testing.html#requirements","title":"Requirements","text":"<p>Before we start, make sure you have the following installed:</p> <ul> <li>Magewire 3.0.0 or later</li> <li>Magento version 2.4.4 or later</li> </ul>"},{"location":"pages/essentials/testing.html#installation","title":"Installation","text":"<ol> <li> <p>CD into the Playwright test folder    <pre><code>cd vendor/magewirephp/magewire/tests/Playwright\n</code></pre></p> </li> <li> <p>Install all dev-dependencies    <pre><code>npm install\n</code></pre></p> </li> <li> <p>Create a <code>.env</code> config file in the root <code>Playwright</code> folder using the following variables:    <pre><code>BASE_URL=https://local.test/\n\nENVIRONMENT=local\nACCOUNT_FIRSTNAME=Veronica\nACCOUNT_LASTNAME=Costello\nACCOUNT_EMAIL=roni_cost@example.com\nACCOUNT_PASSWORD=roni_cost3@example.com\n</code></pre> Set the <code>BASE_URL</code> value with the <code>base-url</code> of your Magento instance.</p> </li> <li> <p>Run tests    <pre><code>npm run test\n</code></pre></p> </li> <li> <p>Run tests manually (optional)    <pre><code>npx playwright test --ui\n</code></pre></p> </li> </ol>"},{"location":"pages/features/alpine.html","title":"Alpine","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/features/magewire-flakes.html","title":"Flakes","text":"<p>Magewire specific (since: 3.0.0)</p> <p>Flakes are reusable UI components that provide a powerful way to create modular, composable elements within your applications. Think of them as self-contained building blocks that can be embedded anywhere within your Magewire components using familiar HTML-like syntax.</p> <p>What makes flakes particularly useful is their flexibility and ease of use. They allow you to encapsulate complex UI logic, styling, and behavior into reusable components that can be shared across different parts of your application. Whether you're building alert messages, form inputs, modal dialogs, or any other UI element, flakes provide a clean and consistent approach to component composition.</p>"},{"location":"pages/features/magewire-flakes.html#example","title":"Example","text":"<p>Flakes use the <code>magewire:</code> prefix (similar to custom elements in Alpine.js or Vue.js) combined with special attributes to bind Magewire-specific data and pass parameters to the component during mounting. You can also bind property values directly using the <code>prop:</code> prefix followed by the property name. This syntax keeps usage intuitive while preserving the full power of Magewire\u2019s reactive capabilities.</p> view/{area}/templates/magewire/foo.phtml<pre><code>&lt;div&gt;\n    Foo!\n\n    &lt;?php $title = 'Hello World' ?&gt;\n    &lt;magewire:message name=\"custom-alert\" prop:type=\"error\" mount:title=\"$title\" /&gt;\n&lt;/div&gt;\n</code></pre> <p>As you can see, any variables defined within the template will automatically be bound as arguments to either a <code>mount</code> method or can be used as component public property values.</p> <p>Let's imagine you need the escaper within the <code>mount</code> method that sits within your Magewire component. You could inject it via the <code>__construct</code> method, but since it already exists within the template, you can do the following:</p> view/{area}/templates/magewire/foo.phtml<pre><code>&lt;div&gt;\n    &lt;magewire:message name=\"custom-alert\" mount:escaper=\"$escaper\" prop:view-model=\"$block\" /&gt;\n&lt;/div&gt;\n</code></pre> <p>Since <code>$escaper</code> is a global variable, you don't need to define it explicitly.</p> <p>The component might look something like this:</p> Vendor\\Module\\Magewire\\Flake\\Message<pre><code>&lt;?php\n\nclass Message extends \\Magewirephp\\Magewire\\Component\n{\n    public function mount(\\Magento\\Framework\\Escaper $escaper)\n    {\n        $this-&gt;title = $title;\n    }\n}\n</code></pre>"},{"location":"pages/features/magewire-flakes.html#registration","title":"Registration","text":"<p>To use flakes, you must first register them in the <code>magewire_flakes.xml</code> layout handle:</p> view/{area}/layout/magewire_flakes.xml<pre><code>&lt;body&gt;\n    &lt;block name=\"flakes.message\"\n           as=\"message\"\n           template=\"Magewirephp_Magewire::magewire/flakes/message.phtml\"\n    &gt;\n        &lt;arguments&gt;\n            &lt;argument name=\"magewire\" xsi:type=\"object\" shared=\"false\"&gt;\n                Magewirephp\\Magewire\\Magewire\\Flake\\Message\n            &lt;/argument&gt;\n        &lt;/arguments&gt;\n    &lt;/block&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"pages/features/magewire-flakes.html#component-class","title":"Component Class","text":"<p>Attributes prefixed with <code>mount:</code> are automatically passed to the component\u2019s <code>mount()</code> method. Template variables can be defined directly using the <code>$foo</code> syntax. This makes passing full objects from your template to your Magewire component easier than ever.</p> Vendor\\Module\\Magewire\\Flake\\Message<pre><code>&lt;?php\n\nclass Message extends \\Magewirephp\\Magewire\\Component\n{\n    public string $type = 'error';\n    public string $title = 'No Title';\n\n    public function mount(string $title)\n    {\n        $this-&gt;title = $title;\n    }\n}\n</code></pre>"},{"location":"pages/features/magewire-flakes.html#template","title":"Template","text":"<p>Finally, create the flake template:</p> view/{area}/templates/magewire/flakes/message.phtml<pre><code>&lt;div role=\"alert\" class=\"message &lt;?= $magewire-&gt;type ?&gt;\"&gt;\n    &lt;div class=\"title text-lg\"&gt;\n        &lt;?= $magewire-&gt;title ?&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"pages/features/magewire-template-directives.html","title":"Template Directives","text":"<p>Magewire specific (since: 3.0.0)</p> <p>Starting from Magewire V3, all templates are precompiled into the generated directory, but only when no existing compilation is found or when the source template has been modified. This pre-compilation is powered by the new Compiling feature, which is now a core part of the framework.</p> <p>Thanks to this feature, simplified <code>@</code>-directives can be used in templates and are automatically compiled into real PHP code. For example, there's no longer a need to include view models just to check session-related logic\u2014such as determining if a customer is a guest or logged in. Instead, you can now simply wrap your logic in <code>@auth</code> and <code>@endauth</code> directives, with any necessary code in between.</p> <p>What's more, the system is designed to be extensible. Developers can easily inject their own custom directives, making the development experience more streamlined and efficient.</p> <p>Example</p> <pre><code>&lt;div&gt;\n    @auth\n        &lt;!-- Will only be shown to logged in customers. --&gt;\n        &lt;span&gt;Hi customer&lt;/span&gt;\n    @endauth\n\n    @guest\n        &lt;!-- Will only be shown to guests. --&gt;\n        &lt;span&gt;Hi guest&lt;/span&gt;\n    @endguest\n\n    @json(value: '{\"firstname\": \"John\", \"lastname\": \"Doe\"}')\n&lt;/div&gt;\n</code></pre>"},{"location":"pages/features/magewire-template-directives.html#directives","title":"Directives","text":"Name Type Area Description Arguments Since <code>@json</code> - Base Json encodes the given value value, default, flags, depth 3.0.0 <code>@if</code> Scope Base Execute on given condition expression 3.0.0 <code>@elseif</code> Scope Base Execute on given condition, after an <code>@if</code> expression 3.0.0 <code>@else</code> Scope Base N/A 3.0.0 <code>@auth</code> Scope Base N/A 3.0.0 <code>@guest</code> Scope Base N/A 3.0.0 <code>@foreach</code> Scope Base expression 3.0.0 <code>@translate</code> Scope Base Translate a string value, escape 3.0.0 <code>@script</code> Scope Base Mark a <code>&lt;script&gt;</code> element N/A 3.0.0 <code>@fragment</code> Scope Base Mark a DOM element as a fragment type 3.0.0 <ol> <li>Scoped directives always require a corresponding <code>@end</code> directive, such as <code>@if</code> ... <code>@endif</code> or <code>@auth</code> ... <code>@endauth</code>.</li> <li>Named arguments are used by default, allowing you to pass arguments in any order.</li> <li>Areas can be custom-defined and act as directive prefixes. For example, the directive escapeHtml belongs to the escape area, indicating it was registered within that namespace.</li> </ol>"},{"location":"pages/features/magewire-template-directives.html#customize","title":"Customize","text":"<p>Got an idea for a custom directive? Go ahead and build it using a bit of dependency injection, the Directive Manager, and our abstraction layer to help you get started.</p> <p>Useful classes to discover are:</p> <p>...\\Features\\SupportMagewireCompiling\\View\\Management</p> <ul> <li>DirectiveManager</li> </ul> <p>...\\Features\\SupportMagewireCompiling\\View</p> <ul> <li>Directive (abstract)</li> <li>DirectiveArea (abstract)</li> <li>ScopeDirective (abstract)</li> <li>Compiler (abstract)</li> </ul> <p>...\\Features\\SupportMagewireCompiling\\View\\Directive</p> <ul> <li>Scope</li> </ul> <p>...\\Features\\SupportMagewireCompiling\\View\\Compiler</p> <ul> <li>MagewireCompiler</li> </ul> <p>..\\Features\\SupportMagewireCompiling\\View\\Directive\\Parser</p> <ul> <li>FunctionArgumentsParser</li> </ul> <p>..\\Support</p> <ul> <li>Parser (abstract)</li> </ul>"},{"location":"pages/features/magewire-template-directives.html#areas","title":"Areas","text":"<p>Areas serve as prefixes for your directives. When you use a directive like <code>@fooBar</code>, the compiler interprets <code>foo</code> as the area and checks if it exists. If it does, it will then invoke the <code>bar</code> directive within that area.</p> File: etc/frontend/di.xml<pre><code>&lt;virtualType name=\"Example\\Module\\Magewire\\Features\\SupportFooDirective\\View\\FooDirectiveArea\"\n             type=\"Magewirephp\\Magewire\\Features\\SupportMagewireCompiling\\View\\DirectiveArea\"\n&gt;\n    &lt;arguments&gt;\n        &lt;argument name=\"directives\" xsi:type=\"array\"&gt;\n\n            &lt;!--\n                Inject the \"bar\" directive into the area.\n            --&gt;\n            &lt;item name=\"bar\" xsi:type=\"object\"&gt;\n                Example\\Module\\Magewire\\Features\\SupportFooDirective\\View\\Directive\\Bar\n            &lt;/item&gt;\n        &lt;/argument&gt;\n    &lt;/arguments&gt;\n&lt;/virtualType&gt;\n\n&lt;type name=\"Magewirephp\\Magewire\\Features\\SupportMagewireCompiling\\View\\Management\\DirectiveManager\"&gt;\n    &lt;arguments&gt;\n        &lt;argument name=\"areas\" xsi:type=\"array\"&gt;\n\n            &lt;!--\n                Inform the Directive Manager about the \"foo\" area.\n            --&gt;\n            &lt;item name=\"foo\" xsi:type=\"object\"&gt;\n                Example\\Module\\Magewire\\Features\\SupportFooDirective\\View\\FooDirectiveArea\n            &lt;/item&gt;\n        &lt;/argument&gt;\n    &lt;/arguments&gt;\n&lt;/type&gt;\n</code></pre>"},{"location":"pages/features/magewire-template-directives.html#directives_1","title":"Directives","text":"<p>There are multiple ways to create a directive. In most cases, the abstraction layer handles the heavy lifting, but you can opt for a more customized approach when the situation requires it.</p> <p>Below are two examples, each demonstrating a different use case that required a unique approach.</p> <p>Example for: <code>@escapeUrl(url: 'https://example.test')</code></p> <p>In this example, the directive class was injected into the escape area, where the <code>url</code> method corresponds to the directive suffix <code>Url</code>.</p> Class: ...\\Features\\SupportMagewireCompiling\\View\\Directive\\Magento\\Escape<pre><code>&lt;?php\n\nclass Escape extends \\Magewirephp\\Magewire\\Features\\SupportMagewireCompiling\\View\\Directive\n{\n    #[\\Magewirephp\\Magewire\\Features\\SupportMagewireCompiling\\View\\Directive\\Parser\\ScopeDirectiveParser(ExpressionParserType::FUNCTION_ARGUMENTS)]\n    public function url(string $url): string\n    {\n        return \"&lt;?= \\$escaper-&gt;escapeUrl({$url}) ?&gt;\";\n    }\n}\n</code></pre> <p>As shown in the example, the method is marked with the <code>FUNCTION_ARGUMENTS</code> attribute, which indicates that the method accepts named function arguments that will be automatically passed to it.</p> Expression Type Description <code>CONDITION</code> Used for conditional expressions and boolean evaluations <code>ITERATION_CLAUSE</code> Used for loop constructs and iterative operations <code>FUNCTION_ARGUMENTS</code> Used for methods that accept named function arguments <p>Example for: <code>@json(value: ['foo' =&gt; 'bar'])</code></p> <p>A directive injected into the Base area, allowing it to be used directly without a prefix.</p> Class: ...\\Features\\SupportMagewireCompiling\\View\\Directive\\Json<pre><code>&lt;?php\n\nclass Escape extends \\Magewirephp\\Magewire\\Features\\SupportMagewireCompiling\\View\\Directive\n{\n    private int $encodingOptions = JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT;\n\n    public function compile(string $expression, string $directive): string\n    {\n        $arguments = $this-&gt;functionArgumentsParser()-&gt;parse($expression)-&gt;arguments();\n\n        $value = $arguments-&gt;get('value', $arguments-&gt;get('default', []));\n        $flags = $arguments-&gt;get('flags', $this-&gt;encodingOptions);\n        $depth = $arguments-&gt;get('depth', 512);\n\n        return \"&lt;?php echo json_encode($value, $flags, $depth) ?&gt;\";\n    }\n}\n</code></pre> <p>Both examples extend from the base Directive class. The first relies on the abstraction's compile method, which automatically looks for a corresponding method with a matching name.</p> <p>The second handles compilation manually, since it only requires a single method.</p> <p>While this could have been solved by defining a public <code>json</code> method, in this case, it was necessary to manually handle <code>$encodingOptions</code> to apply default flags when none are provided by the developer.</p>"},{"location":"pages/features/magewire-template-directives.html#actions","title":"Actions","text":"<p>Magewire directives are compiled into actual PHP code, which is then placed into real .phtml template files. However, it's important to limit the amount of business logic written directly within these templates.</p> <p>Ideally, your directive\u2019s compile method should return clean and minimal PHP, such as:</p> <pre><code>&lt;span&gt;Firstname: &lt;?= $viewModel-&gt;renderCustomerFirstname() ?&gt;&lt;/span&gt;\n</code></pre> <p>As shown above, this relies on a <code>$viewModel</code> object, which must be injected or made available to the template. While you can provide this ViewModel specifically for that template, it quickly becomes less reusable when others want to use the same <code>@</code> directive elsewhere.</p> <p>To solve this, Magewire introduces a global variable called <code>$__magewire</code>, available only within templates rendered as part of a Magewire component. This variable acts as a basic ViewModel \u2014 referred to as Magewire Underscore.</p> <p>The <code>$__magewire</code> ViewModel provides an <code>action()</code> method that accepts a string <code>$class</code> argument. This class can either be:</p> <p>A mapped alias defined in <code>di.xml</code>, or</p> <p>A fully qualified class name that extends the <code>\\Magewirephp\\Magewire\\Features\\SupportMagewireCompiling\\View\\Management\\ActionManager</code>.</p> <p>This approach enables your compiled output to remain clean and consistent across templates. For example:</p> <pre><code>&lt;span&gt;Firstname: &lt;?= $__magewire-&gt;action('mapped.namespace')-&gt;execute('method_name', ...arguments) ?&gt;&lt;/span&gt;\n</code></pre>"},{"location":"pages/features/offline-states.html","title":"Offline States","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/features/request-bundling.html","title":"Request Bundling","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/getting-started/basics.html","title":"Basics","text":"<p>Just getting started with Magewire and want to learn the basics? This page will help you kickstart your development journey!</p> <p>Don\u2019t miss our Notables\u2014a collection of helpful, nice-to-know examples that go beyond the basics.</p>"},{"location":"pages/getting-started/basics.html#layout-xml","title":"Layout XML","text":"<p>The primary method for converting a block into a dynamic Magewire component is by defining the <code>magewire</code> block argument and assigning it a component object using the <code>layout</code> resolver.</p> <p>Refer to the Resolvers section for a deeper understanding of how components are bound to blocks.</p>"},{"location":"pages/getting-started/basics.html#arguments","title":"Arguments","text":"<p>Since Magewire V3, you can pass arguments to components via block data using the magewire prefix, followed by either a dot <code>.</code> or a colon <code>:</code> separator.</p> <ul> <li>Use <code>magewire.</code> for individual component property values.</li> <li>Use <code>magewire:</code> for grouped arguments.</li> </ul> <pre><code>&lt;block name=\"counter\" template=\"Example_Module::magewire/counter.phtml\"&gt;\n    &lt;arguments&gt;\n        &lt;argument name=\"magewire\" xsi:type=\"object\"&gt;\n            ...\n        &lt;/argument&gt;\n\n        &lt;!-- Single public $foo property value assignment. --&gt;\n        &lt;argument name=\"magewire.foo\" xsi:type=\"string\"&gt;\n            baz\n        &lt;/argument&gt;\n\n        &lt;!-- Grouped for specific purposes like the \"mount\" or \"boot\" method. --&gt;\n        &lt;argument name=\"magewire:mount:start\" xsi:type=\"number\"&gt;\n            19\n        &lt;/argument&gt;\n    &lt;/arguments&gt;\n&lt;/block&gt;\n</code></pre> <p>Adding arguments to the <code>mount</code> method via layout XML should not be mistaken for standard dependency injection used in the <code>__construct</code> method.</p> <p>The component looks like:</p> <pre><code>&lt;?php\n\nclass Counter extends \\Magewirephp\\Magewire\\Component\n{\n    // Value of $foo becomes \"baz\" thanks to the \"magewire.foo\" XML argument.\n    public string $foo = 'bar';\n\n    public int $count = 0;\n\n    public function mount(int $start = 1337)\n    {\n        // Value of $count becomes \"19\" thanks to the \"magewire:mount:start\" XML arguments.\n        $this-&gt;count = $start;\n    }\n}\n</code></pre>"},{"location":"pages/getting-started/beta.html","title":"Beta","text":"<p>Beta release</p> <p>Do not use Magewire V3 in production, as its stability, security, and overall reliability cannot be guaranteed. The framework is still in an beta phase, and breaking changes may occur without warning. Using it in a live environment is entirely at your own risk and may lead to unexpected issues, including potential security vulnerabilities and system instability.</p> <p>As of June 1st, the Magewire V3 Beta has been officially released for testing.</p> <p>This beta version gives developers an opportunity to explore what's new, what has changed, and what updates may be required to ensure compatibility with their existing implementations.</p> <p>We encourage you to try out the beta, provide feedback, and report any issues you encounter. Your input helps shape a stable and reliable final release.</p>"},{"location":"pages/getting-started/beta.html#rough-state","title":"Rough State","text":"<p>Magewire V3 is still in a rough beta state, meaning that while the core architecture is in place, many features still need to be fine-tuned and battle-tested before the package can be considered stable.</p> <p>One of the key goals during this phase is to increase test coverage to ensure that no bugs slip through when new releases are published.</p> <p>That said, the beta tag also signals that the overall architecture is solid and unlikely to undergo major changes, as it largely follows the structure of Livewire. The foundation is there\u2014but it still needs polish and real-world feedback before it's production-ready.</p>"},{"location":"pages/getting-started/beta.html#work-in-progress","title":"Work In Progress","text":"<p>Some pages or sections are marked with <code>WIP...</code>, indicating that they are important areas requiring further attention and should or will be completed soon.</p>"},{"location":"pages/getting-started/beta.html#github-discussions","title":"GitHub Discussions","text":"<p>We encourage developers to actively contribute to the project. If you discover a bug, please consider submitting a pull request with a fix.</p> <p>Alternatively, you can start a discussion in the GitHub repository\u2014just make sure to include as many details as possible to help us understand and reproduce the issue.</p> <p>For feature ideas or proposals, we welcome discussions as well. To help us organize and track ideas related to the upcoming version, please prefix your GitHub discussion title with <code>[V3]</code>. </p>"},{"location":"pages/getting-started/beta.html#duration-of-the-beta","title":"Duration of the Beta","text":"<p>There is no fixed timeline for how long the beta will last.</p> <p>However, a key milestone is to implement all features that Magewire V1 offered, enabling existing projects to migrate smoothly to V3. The beta may conclude once these goals are achieved.</p>"},{"location":"pages/getting-started/contribute.html","title":"Contribute","text":"<p>Magewire is a completely independent framework, unaffiliated with any organization or company.</p> <p>These docs are constantly evolving, requiring updates and improvements as the framework gains new features. That\u2019s why we encourage users to spot typos, fill in missing details, or clarify unclear sections by contributing.</p> <p>Writing good documentation is a skill in itself\u2014one that takes time to master. It requires a deep understanding of a feature and the ability to explain it concisely yet clearly, providing enough information for others to grasp it at a glance.</p>"},{"location":"pages/getting-started/contribute.html#why-contribute","title":"Why Contribute","text":"<p>Contributing to an open-source project comes with many benefits. It\u2019s not just about investing your free time\u2014you also gain valuable skills and knowledge along the way.</p> <p>Some benefits of contributing to an open-source project include:</p> <ul> <li>Learning from others</li> <li>Refining your skills</li> <li>Giving and receiving feedback</li> <li>Expanding your portfolio</li> <li>Improving job market opportunities</li> <li>Networking and building connections</li> </ul>"},{"location":"pages/getting-started/contribute.html#your-contributions-matter","title":"Your Contributions Matter","text":"<p>Every developer has faced that moment\u2014the hesitation, the self-doubt, the feeling of being overwhelmed when stepping beyond their comfort zone to contribute. Thoughts like Am I good enough? What if I make mistakes? or Others are smarter than me can spiral into inaction, stopping you from making the changes that could improve not only your workflow but the project as a whole.</p> <p>But here\u2019s the truth: every contribution matters, no matter your experience level. We welcome all contributions, big or small, because each one gives us valuable insight into how developers interact with the framework. Your perspective helps us identify gaps in the documentation, refine features, and even spark new ideas and innovations.</p> <p>Not every pull request will be merged instantly, but every submission will be reviewed and acknowledged. We\u2019ll provide feedback, guide you where needed, and sometimes even refine your work so you can learn from the process.</p> <p>So take that step\u2014your contributions make a difference. We\u2019re excited to see what you bring to the table!</p>"},{"location":"pages/getting-started/contribute.html#areas","title":"Areas","text":"<p>We welcome all kinds of contributions\u2014it\u2019s not just about writing code!</p> <p>Here are some ways you can contribute:</p> <ul> <li>Developing new features</li> <li>Improving existing code</li> <li>Writing tests</li> <li>Creating third-party extensions based on Magewire</li> <li>Improving documentation</li> <li>Spreading the word</li> </ul>"},{"location":"pages/getting-started/documentation.html","title":"Documentation","text":"<p>These docs are still under active development, with the goal of providing as much useful content as possible. Given that Magewire is a large package with many possibilities, it's challenging to cover everything out of the box. We appreciate your understanding.</p> <p>Magewire is heavily inspired by Livewire, and as a result, most of its core functionality works in the same way. For this reason, all essential documentation can be found in the official Livewire documentation.</p> <p>The Magewire documentation primarily focuses on Magento-specific implementations, custom features, and additional explanations that are either missing from the Livewire docs or are not relevant due to platform differences.</p> <p>If you're looking for a deeper understanding of how Magewire works under the hood, we highly recommend referring to the Livewire documentation alongside this guide.</p>"},{"location":"pages/getting-started/documentation.html#disclaimer","title":"Disclaimer","text":"<p>These docs are written based on the knowledge and experience we had at the time of writing.</p> <p>If you notice anything incorrect, unclear, in need of expansion, or outdated, feel free to open a pull request. We\u2019ll review it as soon as possible.</p>"},{"location":"pages/getting-started/documentation.html#tone-of-voice","title":"Tone of Voice","text":"<p>The tone of voice should always be professional, clear, and inclusive. We write from a \"we\" perspective rather than an \"I\" perspective to reflect a collaborative effort.</p> <p>Since these docs are primarily aimed at developers, we use a direct and instructional tone when providing step-by-step guidance. Addressing the reader with \"you\" ensures clarity and engagement.</p> <p>Key Principles:</p> <ul> <li>Clarity &amp; Precision \u2013 Avoid ambiguity and unnecessary complexity. Be concise but thorough.</li> <li>Consistency \u2013 Use a uniform tone and terminology throughout the documentation.</li> <li>Respect &amp; Inclusivity \u2013 We respect and welcome everyone. Our language should be neutral, inclusive, and non-discriminatory.</li> <li>Empathy \u2013 If something is unclear or if our tone ever feels unwelcoming, we encourage feedback. Please let us know, and we will work to improve it.</li> <li>Encouraging &amp; Helpful \u2013 When explaining concepts, especially for beginners, be supportive and assume good intent.</li> </ul> <p>By following these guidelines, we aim to create documentation that is helpful, approachable, and professional for all developers.</p>"},{"location":"pages/getting-started/documentation.html#navigation","title":"Navigation","text":"<p>The navigation structure has been mirrored from the Livewire 3 documentation, with a few additions. The goal is to keep things in sync, making content easier to navigate and understand.</p>"},{"location":"pages/getting-started/documentation.html#structure","title":"Structure","text":"<p>The Magewire documentation is intentionally structured in a way that closely follows the Livewire documentation. This has been done to create a sense of familiarity, making navigation more intuitive and helping users better understand how different concepts relate to each other. If you're already familiar with Livewire, you should find it easy to adapt to Magewire.</p> <p>To avoid unnecessary duplication, pages that exist in both the Magewire and Livewire documentation will always include a direct link to the corresponding Livewire page for quick access. The Magewire documentation will only contain additional information specific to Magewire, such as Magento-specific implementations, platform-specific limitations, and custom features.</p> <p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p> <p>We deliberately avoid copying and pasting content from the Livewire documentation. Instead, our goal is to complement it with details that are unique to Magewire, ensuring you get the most relevant and accurate information without redundancy.</p>"},{"location":"pages/getting-started/documentation.html#clarity","title":"Clarity","text":"<p>We strive to keep this documentation as clean and clear as possible. This means that, in most cases, page titles will consist of a single word rather than a full sentence. Titles are carefully chosen to be self-explanatory, ensuring that readers can quickly understand the topic at a glance.</p> <p>The goal is to make navigation intuitive and to avoid unnecessary complexity. By keeping titles concise, it becomes easier to scan through the documentation and find the information you need without distractions. If a topic requires further clarification, the content of the page itself will provide the necessary details.</p>"},{"location":"pages/getting-started/documentation.html#contribute","title":"Contribute","text":"<p>If you notice any missing details or information in this documentation, please refer to the Contribution section. We encourage everyone to contribute and help make the documentation as clear and accessible as possible for everyone.</p>"},{"location":"pages/getting-started/documentation.html#includes","title":"Includes","text":"<p>The following blocks are included as a preview of what to expect within these docs.</p> <p>Livewire Concept</p> <p>Livewire Concept</p> <p>To indicate that the explanation pertains to Livewire.</p> <p>Livewire Reference</p> <p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p> <p>Magewire is heavily inspired by Livewire and, in many cases, works identically. As a result, rewriting the same documentation would not only require a significant time investment but also create confusion when changes occur in either project.</p> <p>Therefore, referring to the original Livewire documentation makes more sense.</p> <p>However, this does not mean that everything in the Livewire documentation applies to Magento. Some features are specific to Laravel, some may not make sense in the Magewire context, and others might be in development.</p> <p>Magewire Experimental</p> <p>Experimental</p> <p>Experimental features are still in development and may change, break, or be removed in future versions. Use with caution and provide feedback where possible.</p> <p>Magewire is an ambitious experiment with serious intentions. Some features should already be documented but require an experimental flag to indicate that they are subject to change and should not be used in a production environment.</p> <p>Magewire Specific</p> <p>Magewire specific (since: 3.0.0)</p> <p>For Magewire-specific features, we are introducing a \"Magewire Specific\" block. This serves as a clear indicator that the content applies specifically to Magewire and also displays the version in which the feature was introduced.</p> <p>While version-specific documentation with a version selector could be an option in the future, we currently do not see an immediate need for it, and implementing it would be a significantly larger project.</p>"},{"location":"pages/getting-started/documentation.html#ai","title":"AI","text":"<p>Writing good documentation is a skill in itself. An explanation can be technically accurate but may not always be clear, concise, or well-structured in terms of vocabulary and readability. To enhance the quality of our documentation, we use AI as an assistant, but with clear boundaries.</p> <p>Writing Guidelines:</p> <ul> <li>AI as a Writing Aid, Not a Replacement \u2013 AI helps refine wording, improve clarity, and enhance readability. However, it does not replace human judgment or expertise.</li> <li>Human Oversight is Essential \u2013 Every AI-generated suggestion must be reviewed and approved by a human to ensure it aligns with our documentation standards and intent.</li> <li>No AI-Generated Code \u2013 AI should not be used to write the initial code examples. Code should be written by developers first, ensuring correctness, best practices, and relevance. AI may assist in refining or improving existing code, but all changes must be carefully reviewed by a developer.</li> <li>Maintain Consistency \u2013 AI should be used to align tone and structure but must follow the established style and technical accuracy of the documentation.</li> </ul> <p>By using AI thoughtfully and responsibly, we ensure that our documentation remains human-centered, high-quality, and reliable while benefiting from AI-driven enhancements.</p> <p>Future Considerations: Automated Tone of Voice Checks</p> <p>We are exploring the possibility of implementing a GitHub action workflow that periodically reviews all Markdown files within the pages folder. The goal is to ensure a consistent tone of voice throughout the entire documentation.</p> <p>While this is not a priority at the moment, it remains a potential future improvement to maintain quality and uniformity in our documentation.</p> <p>This prompt can be used when requesting AI to refine and enhance a specific section of your writing.</p> <pre><code>WIP...\n</code></pre>"},{"location":"pages/getting-started/examples.html","title":"Examples","text":"<p>WIP...</p>"},{"location":"pages/getting-started/examples.html#projects","title":"Projects","text":"Name Uses Version Commercial Vendor Website Hyv\u00e4 Checkout <code>^1.12.*</code> Yes Hyv\u00e4 OpenPOS <code>^1.*</code> Yes Zero-1 Hyv\u00e4 CMS <code>^1.*</code> Yes Hyv\u00e4"},{"location":"pages/getting-started/examples.html#packages","title":"Packages","text":"<p>In addition to the Magewire core, there are several other MagewirePHP packages that may be of interest.</p> Name Uses Version Vendor Repository Admin <code>^3.*</code> MagewirePHP N/A <p>Feel free to open a pull request to ensure your project is listed. Whether big or small, any project can serve as great inspiration for others to start working with Magewire.</p>"},{"location":"pages/getting-started/faq.html","title":"FAQ","text":""},{"location":"pages/getting-started/faq.html#what-is-magewire","title":"What is Magewire?","text":"<p>MagewirePHP brings the power of reactive, server-driven UI development to Magento 2\u2014without writing JavaScript. Inspired by Laravel Livewire, MagewirePHP lets you build dynamic, interactive frontend components using only PHP, fully integrated with Magento\u2019s architecture.</p> <p>Whether you're creating real-time search, dynamic product forms, or interactive checkout steps, MagewirePHP enables a clean, component-based approach that stays true to Magento\u2019s conventions while simplifying complex frontend behavior.</p> <p>MagewirePHP helps you deliver modern UX experiences in Magento\u2014faster, cleaner, and with less frontend overhead.</p>"},{"location":"pages/getting-started/faq.html#why-use-magewire","title":"Why Use Magewire?","text":"<p>Apart from a few frameworks attempting to mimic Magewire's concept, it is a proven framework not only within the Magento community but, more importantly, within the Laravel community, where it has become one of the most widely used third-party frameworks.</p> <p>With approximately 3,000 weekly downloads of Magewire V1, Magewire V3 is poised to surpass that record.</p>"},{"location":"pages/getting-started/faq.html#when-is-magewire-the-right-choice","title":"When Is Magewire the Right Choice?","text":"<p>Magewire doesn\u2019t make sense everywhere, but with Magewire V3, it has become much more feature-rich. It no longer just makes blocks dynamic; it offers a variety of powerful features, making it a great choice in certain situations.</p> <p>We like to describe a Magewire component as a \"View Model on steroids.\" While providing examples can be helpful, it might limit developers' creativity and detract from the curiosity we aim to foster.</p> <p>If we offer a list of examples that doesn\u2019t suit your needs, you might overlook the framework entirely. However, with just a little exploration, Magewire could be the perfect fit for your project.</p>"},{"location":"pages/getting-started/faq.html#what-are-the-key-differences-between-magewire-v1-and-v3","title":"What Are the Key Differences Between Magewire V1 and V3?","text":"<p>Magewire V1 started as an experiment that quickly gained traction, especially after Hyv\u00e4 embraced the framework for its products. Others soon followed, building filtering systems, configurators, and quick order components on top of it. Over time, a lot was built on the framework\u2014despite it not being originally designed to support such a wide range of features.</p> <p>Magewire V3, however, is a different story. It has been developed with a structure much closer to Livewire V3, reusing a significant amount of its core code. A thin wrapper integrates it seamlessly into Magento, making upgrades easier and enabling a more modular approach to building new features.</p> <p>Additionally, a custom router was introduced to improve performance, resulting in a notable ~33% performance gain.</p>"},{"location":"pages/getting-started/faq.html#what-will-happen-to-magewire-v1","title":"What Will Happen to Magewire V1?","text":"<p>Active development on this project has ceased, meaning no new features will be added.</p> <p>Merge requests are still welcome, and bug fixes may be addressed depending on the time investment required.</p> <p>Security updates will continue to be applied until January 1st, 2026.</p>"},{"location":"pages/getting-started/faq.html#are-all-features-from-v1-already-available-in-v3","title":"Are All Features from V1 Already Available in V3?","text":"<p>At the time of writing, this is not yet the case. However, the most commonly used features are already available.</p> <p>While there is never a perfect time to release V3, the current architecture makes porting features and ensuring compatibility easier than ever.</p>"},{"location":"pages/getting-started/faq.html#can-i-upgrade-from-magewire-v1-to-v3","title":"Can I Upgrade from Magewire V1 to V3?","text":"<p>Using the upgrade guide should get you most of the way there. However, you might still encounter some issues \u2014 in those cases, we encourage you to troubleshoot them yourself or reach out for support on our Discord.</p> <p>If you encounter any issues while upgrading, please report them via GitHub Issues.</p>"},{"location":"pages/getting-started/faq.html#can-magewire-be-used-with-the-luma-theme","title":"Can Magewire Be Used with the Luma Theme?","text":"<p>Magewire has been specifically designed to be Hyv\u00e4-first, meaning it works seamlessly with the Hyv\u00e4 theme right out of the box.</p> <p>That said, thanks to its flexible architecture, Magewire can also be made compatible with other themes. In fact, it has already been made compatible with the admin panel.</p>"},{"location":"pages/getting-started/faq.html#will-hyva-checkout-use-magewire-v3","title":"Will Hyv\u00e4 Checkout Use Magewire V3?","text":"<p>Magewire is an independent framework, with support from Hyv\u00e4 through contributions to areas necessary for its products.</p> <p>Whether it will be officially supported is beyond our control, so we cannot make any guarantees or statements about that.</p>"},{"location":"pages/getting-started/faq.html#can-v1-and-v3-run-simultaneously","title":"Can V1 and V3 run simultaneously?","text":"<p>No, this is not possible. Magewire V3 is a complete rewrite, though it maintains backward compatibility where feasible.</p> <p>However, features that were specifically built for Magewire V1 will need to be updated to work with V3.</p> <p>The upgrade process shouldn't be difficult\u2014just follow the steps outlined in the Upgrade Guide, which will help you migrate your code smoothly.</p>"},{"location":"pages/getting-started/faq.html#where-can-i-find-the-v1-documentation","title":"Where can I find the V1 Documentation?","text":"<p>V1 documentation can be found here</p>"},{"location":"pages/getting-started/license.html","title":"License","text":"<p>Disclaimer</p> <p>This MagewirePHP packages are provided as is, without any warranties or guarantees. Use it at your own risk. We are not responsible for any issues, damages, or consequences that may arise from its use, and no claims can be made against us for any reason.</p> <p>MagewirePHP is an open-source project licensed under the MIT License. This means you are free to use, modify, distribute, and even incorporate MagewirePHP into commercial projects, as long as you include the original license and copyright notice.</p>"},{"location":"pages/getting-started/license.html#mit-license-overview","title":"MIT License Overview","text":"<p>The MIT License is a permissive open-source license that grants broad freedoms while requiring minimal obligations. Below are the key points:</p> <ul> <li>Free Use \u2013 You are allowed to use MagewirePHP for personal, commercial, and open-source projects.</li> <li>Modification &amp; Distribution \u2013 You can modify the source code and distribute it without restriction.</li> <li>No Warranty \u2013 The software is provided \"as is,\" without any warranties or guarantees. The authors are not liable for any damages resulting from its use.</li> </ul> <pre><code>MIT License\n\nCopyright (c) [YEAR] MagewirePHP Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy  \nof this software and associated documentation files (the \"Software\"), to deal  \nin the Software without restriction, including without limitation the rights  \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell  \ncopies of the Software, and to permit persons to whom the Software is  \nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all  \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  \nSOFTWARE.\n</code></pre>"},{"location":"pages/getting-started/license.html#how-to-attribute-the-license","title":"How to Attribute the License","text":"<p>If you use MagewirePHP in your project, please ensure the MIT License notice is included in your source code and/or project documentation.</p> <p>For more details about the MIT License, visit: https://opensource.org/licenses/MIT</p>"},{"location":"pages/getting-started/notables.html","title":"Notables","text":"<p>Notables are brief, helpful insights that highlight useful context or nuances. They\u2019re not meant to be buried in the main text, nor do they require a full deep-dive explanation \u2014 they simply make small but important details clearer at a glance.</p>"},{"location":"pages/getting-started/notables.html#the-magewire-block","title":"The Magewire Block","text":"<p>We aim to keep JavaScript-related .phtml files as minimal and clean as possible. These templates are architected to live within a wrapping <code>magewire</code> block, which comes with both benefits and trade-offs. One such trade-off is that many of these blocks require the <code>Magewirephp\\Magewire\\ViewModel\\Magewire</code> view model to function properly.</p> <p>Manually assigning a <code>view_model</code> argument to each block would not only be tedious but would also result in a significant increase in XML configuration lines. To address this, Magewire includes a small feature that automatically injects the <code>view_model</code> argument into all sibling blocks contained within a <code>magewire</code> block.</p> <p>In practice, this means that as long as your block resides inside the <code>magewire</code> block\u2014whether directly or as a sibling\u2014you can access the view model via <code>$block-&gt;getViewModel()</code> or <code>$block-&gt;getData('view_model')</code>.</p> <pre><code>&lt;!-- A container that sits within the \"magewire\" block. --&gt;\n&lt;referenceContainer name=\"magewire.features\"&gt;\n\n    &lt;!-- The \"view_model\" argument is automatically bound. --&gt;\n    &lt;block name=\"foo\" template=\"...\"/&gt;\n&lt;/referenceContainer&gt;\n</code></pre> <p>However, please note: if you move a block outside the <code>magewire</code> wrapper block, you'll need to manually bind the <code>view_model</code> argument. This is precisely why the view model is passed as an argument instead of being exposed as a global dictionary variable\u2014to avoid forcing developers to rewrite the template just to maintain compatibility.</p> <p>Also, if the block already has a <code>view_model</code> argument defined, Magewire will skip it automatically.</p>"},{"location":"pages/getting-started/notables.html#magewire-view-model","title":"Magewire View Model","text":"<p>Subject Class: \\Magewirephp\\Magewire\\ViewModel\\Magewire</p> <p>In Magewire V1, the Magewire View Model gradually became a collection of helper methods, mostly used to pass small bits of data to templates. This approach was functional, but over time, it became cluttered. In Magewire V3, this has been overhauled: many of those helper methods have been deprecated and moved into dedicated utility classes, accessible via the <code>utils()</code> method.</p> view/frontend/templates/example.phtml<pre><code>&lt;?php\n\n$magewireViewModel = $block-&gt;getData('view_model')\n\n&lt;?php if ($magewireViewModel-&gt;utils()-&gt;env()-&gt;isDeveloperMode()): ?&gt;\n    ...\n&lt;?php endif ?&gt;\n</code></pre> <p>You can extend this system by implementing the <code>Magewirephp\\Magewire\\Model\\View\\UtilsInterface</code> in your own utility class:</p> etc/di.xml<pre><code>&lt;type name=\"Magewirephp\\Magewire\\Model\\View\\Utils\"&gt;\n    &lt;arguments&gt;\n        &lt;argument name=\"utilities\" xsi:type=\"array\"&gt;\n            &lt;item name=\"myCustomTechnology\" xsi:type=\"object\"&gt;\n                Example\\Module\\Magewire\\Features\\SupportCustomTechnology\\View\\Utils\\MyCustomTechnology\n            &lt;/item&gt;\n        &lt;/argument&gt;\n    &lt;/arguments&gt;\n&lt;/type&gt;\n</code></pre> <p>Your utility class might look like this:</p> Example/Module/Magewire/Featuers/SupportCustomTechnology/View/Utils/MyCustomTechnology.php<pre><code>&lt;?php\n\nnamespace Example\\Module\\Magewire\\Features\\SupportCustomTechnology\\View\\Utils;\n\nclass MyCustomTechnology implements \\Magewirephp\\Magewire\\Model\\View\\UtilsInterface\n{\n    public function foo(): string {}\n    public function bar(): string {}\n}\n</code></pre> <p>To finally have:</p> view/frontend/templates/example.phtml<pre><code>&lt;?php\n\n$magewireViewModel = $block-&gt;getData('view_model')\n\n// Two examples on how to call your custom utility.\n$foo = $magewireViewModel-&gt;utils('myCustomTechnology')-&gt;foo();\n$bar = $magewireViewModel-&gt;utils()-&gt;myCustomTechnology()-&gt;bar();\n</code></pre> <p>Note: Providing a custom View Model directly is still perfectly valid.</p>"},{"location":"pages/getting-started/notables.html#magewire-view-fragments","title":"Magewire View Fragments","text":"<p>View Fragments can also be used outside Magewire components!</p> <p>View Fragments\u2014or simply fragments\u2014are self-contained sections of code, typically HTML, that can be both validated and programmatically modified. The concept was originally introduced to provide a clean and reliable solution for making <code>&lt;script&gt;</code> tags within template files CSP-compliant.</p> <p>Since then, the idea has evolved and proven useful in many other areas where dynamic and secure rendering is required.</p> Example_Module::view/frontend/templates/example.phtml<pre><code>&lt;?php $fragment = $magewireViewModel-&gt;utils()-&gt;template()-&gt;fragment() ?&gt;\n\n&lt;?php $script = $fragment-&gt;script()-&gt;start() ?&gt;\n&lt;script&gt;\n    // JS code goes here...\n&lt;/script&gt;\n&lt;?php $script-&gt;end() ?&gt;\n</code></pre> <p>For a deeper dive, refer to the Fragments page.</p>"},{"location":"pages/getting-started/notables.html#component-reusability","title":"Component Reusability","text":"<p>A Magewire component class can be bound to a layout block\u2014for example, via layout XML. If you're using this method and want to reuse the same component class across multiple blocks, you must set the <code>shared</code> flag to <code>false</code>.</p> <p>This ensures each block gets its own instance of the component rather than sharing a single one leading into conflicts.</p> <p>If you're resolving a Magewire component in a different way (outside of layout XML), we recommend using a Factory to create new instances as needed.</p> <pre><code>&lt;block name=\"foo\" template=\"Example_Module::magewire/foo.phtml\"&gt;\n    &lt;arguments&gt;\n        &lt;argument name=\"magewire\" xsi:type=\"object\" shared=\"false\"&gt;\n            Example\\Module\\Magewire\\Foo\n        &lt;/argument&gt;\n    &lt;/arguments&gt;\n&lt;/block&gt;\n\n&lt;block name=\"bar\" template=\"Example_Module::magewire/bar.phtml\"&gt;\n    &lt;arguments&gt;\n        &lt;argument name=\"magewire\" xsi:type=\"object\" shared=\"false\"&gt;\n            Example\\Module\\Magewire\\Foo\n        &lt;/argument&gt;\n    &lt;/arguments&gt;\n&lt;/block&gt;\n</code></pre> <p>For more details on how to bind a Magewire component to a layout block, please refer to the Resolver section.</p>"},{"location":"pages/getting-started/purpose.html","title":"Purpose","text":"<p>Magento has evolved over time, and certain aspects of its PHP architecture and development approach may not align with current trends. This is understandable, given the platform's age and the challenges of modernizing certain concepts without extensive restructuring.</p> <p>In recent years, alternatives have emerged that offer more modern and streamlined development techniques, particularly on the frontend. Magewire takes a similar approach, leveraging its architecture to introduce new features and concepts while trying to stay somewhat aligned with Magento's core principles.</p> <p>Magewire tries to further modernize Magento by offering a proven solution, much like Hyv\u00e4 did with Tailwind CSS and Alpine JS. Over the years, we've seen many new technologies emerge\u2014some that borrow ideas from other frameworks and try to do things  just that little bit different, or ones that were built by accident but never really took off. This often happens because our open-source community tends to focus more on using tools than contributing back to them.</p> <p>We've seen this cycle before, like when Snow Dog introduced two themes. While they were used, issues often led to complaints instead of solutions. As a result, the Snow Dog team ended up managing issues rather than working on improvements.</p> <p>Magewire aims to change this by offering a framework that's already proven. With Laravel Livewire, we've seen developers embrace its simplicity and power. Magewire V3 stays close to Livewire V3\u2019s architecture, making it easy for Magento developers to experience the same smooth workflow and productivity.</p>"},{"location":"pages/getting-started/purpose.html#more-than-a-port","title":"More than a Port","text":"<p>Magewire is more than just a Livewire port; it draws inspiration from Laravel, particularly its simplicity. While Magewire primarily focuses on enabling dynamic component development, it also includes a range of enhancements that accelerate Magento feature development and improve the developer experience.</p>"},{"location":"pages/getting-started/purpose.html#shake-things-up","title":"Shake Things Up","text":"<p>Magewire aims to shake things up by introducing modern, innovative concepts. Yes, this requires a different approach to development, but everything within a Magewire component is entirely optional. Traditional Magento workflows remain fully supported.</p> <p>By modernizing Magento\u2019s development experience, Magewire seeks to (also) attract a new generation of developers who prefer a more streamlined approach. Simplifying certain Magento concepts makes backend development more approachable and enjoyable.</p>"},{"location":"pages/getting-started/purpose.html#the-long-term","title":"The Long Term","text":"<p>Magewire is a powerful, feature-rich package with a bold vision for the future. With version 3, we aim to make it the default choice for both frontend and backend developers\u2014whether for use in themes or to build dynamic admin panel features.</p> <p>The future of Magewire lies in the passion, contributions, and support of its community. It has the potential to redefine backend development and reshape the way developers interact with Magento.</p> <p>Combined with forward-thinking frontend solutions like Hyv\u00e4, Magewire can help Magento reclaim or push forward its place at the forefront of modern development\u2014ushering in a new era driven by fresh ideas and a willingness to embrace change.</p>"},{"location":"pages/getting-started/roadmap.html","title":"Roadmap","text":""},{"location":"pages/getting-started/roadmap.html#2025","title":"2025","text":"Initiative Description Priority Status Beta Release Finalize V3 beta launch with public code access. Target release before October 2025 to gather community feedback and validate core functionality. High Finished Enhanced Debug Tools Expand developer debugging capabilities beyond current tools. Research and implement additional debugging options to streamline the development experience. Medium Planning Browser Test Suite Establish comprehensive testing framework using Playwright. Develop extensive examples module with automated browser tests to ensure framework stability as it scales. High Not Started Feature Migration Complete migration of remaining V1 features to V3. Prioritize features based on usage analytics and community feedback while maintaining full backwards compatibility. High In Progress"},{"location":"pages/getting-started/roadmap.html#2026","title":"2026","text":"<p>No plans yet.</p>"},{"location":"pages/getting-started/sponsoring.html","title":"Sponsoring","text":"<p>The purpose of open-source sponsorship should never be seen as begging for money. It is always voluntary and cannot be tied to any obligations. Instead, it is a way to show appreciation for a project that provides meaningful benefits to you as a developer or to your company.</p> <p> Start Sponsoring</p> <p>Magewire is entirely driven by volunteers who dedicate their free time to the project. Their contributions are not motivated by financial gain but by a desire to enhance their skills, improve a package they rely on in their daily work, thrives their business and/or create better software. Sponsorship is always on an individual basis, as this project is independent of any company or organization.</p>"},{"location":"pages/getting-started/sponsoring.html#sponsors","title":"Sponsors","text":"Sponsor Description Website Vendic Fast, reliable Magento 2 webshops for everyone. <p>Only higher-tier sponsors will be highlighted in the listing above.</p>"},{"location":"pages/getting-started/sponsoring.html#contributors","title":"Contributors","text":"Contributor About Website Justin van Elst Justin played a vital role in bringing Magewire 3 to life by developing the Portman merging tool, which developers must use when contributing to the framework. Hyv\u00e4 Magewire has been the driving force behind Hyv\u00e4 Checkout and Hyv\u00e4 CMS, enabling functionalities that would not have been possible in such a simple and developer-friendly way. Therefore, Hyv\u00e4 has invested a significant amount of time in the development of Magewire V1 and V3, particularly in the areas they rely on the most. <p>Only key contributors will be highlighted in the list above. Key contributors are determined based on the significance of their input. Other contributors can be found on the GitHub repository page.</p>"},{"location":"pages/getting-started/upgrade.html","title":"Upgrade","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/getting-started/upgrade.html#versioning","title":"Versioning","text":"<p>It\u2019s important to clarify that Magewire V2 never existed. This decision was made to align major versioning with Livewire and avoid confusion, as Magewire V1 was based on Livewire V2, which already raised questions. With Magewire V3, this issue has been resolved, and version 2 was skipped entirely.</p>"},{"location":"pages/getting-started/upgrade.html#requirements","title":"Requirements","text":"<p>Alpine JS</p> <p>AlpineJS must be removed from your instance before using Magewire. Since Magewire's JavaScript library already includes AlpineJS, having multiple instances can cause conflicts and unexpected issues.</p> <ul> <li>Magento version 2.4.4 or later</li> <li>PHP version 8.1 or later</li> </ul>"},{"location":"pages/getting-started/upgrade.html#breaking-changes","title":"Breaking Changes","text":"<p>The first version of Magewire started as an experiment, with no clear direction or certainty about its future. This meant that some assumptions were made\u2014some of which turned out to be incorrect. These need to be corrected to stay aligned with Livewire\u2019s changes and to ensure that certain features, or those relying on specific concepts, function as intended. </p>"},{"location":"pages/getting-started/upgrade.html#array-property-hooks","title":"Array Property Hooks","text":"<p>WIP...</p>"},{"location":"pages/getting-started/releases/changelog.html","title":"Change Log","text":"<p>WIP...</p>"},{"location":"pages/getting-started/releases/feature-history.html","title":"Feature History","text":"<p>This list found below provides an overview of newly introduced features across different versions. Each version listed includes a bullet-point summary of what has been added, ensuring a quick and clear understanding of new capabilities.</p> <p>Versions not included in this log indicate releases where no new features were introduced.</p>"},{"location":"pages/getting-started/releases/feature-history.html#300-beta1","title":"3.0.0-beta1","text":"<ul> <li>Dedicated Documentation</li> </ul> <p>Unlike V1, Magewire V3 now features its own dedicated, GitHub-hosted documentation, powered by MkDocs.</p> <p>By moving the documentation out of the core repository and into a centralized location, we aim to provide a more   structured and accessible knowledge base.</p> <p>This dedicated space makes it easier to find answers, stay up to date, and get inspired\u2014ultimately helping developers build better,   more powerful features with Magewire.</p> <ul> <li>Template @ Directives</li> </ul> <p>Using template <code>@</code> directives allows developers to write simplified syntax that is transformed into more complex PHP code during template compilation.   Templates are automatically recompiled whenever a <code>.phtml</code> file is modified, ensuring changes are always up to date.</p> <ul> <li>Template Fragments</li> </ul> <p>Provides the ability to mark a specific area within a template, allowing modifiers to alter its content\u2014such as   making inline scripts CSP compliant. This is done using the <code>$fragment = $viewModel-&gt;utils()-&gt;template()-&gt;fragment()</code> chain,   followed by <code>$script = $fragment-&gt;script()-&gt;start()</code> and <code>$script-&gt;end()</code> to define the fragment boundaries.</p> <p>For more details, please refer to the Fragments documentation.</p> <ul> <li>Automatic View Model Resolving</li> </ul> <p>Blocks that are direct or indirect children of the magewire block will automatically receive a <code>view_model</code> argument\u2014as   long as it hasn\u2019t already been manually defined. This reduces the need to explicitly bind the <code>view_model</code> to each individual block,   resulting in cleaner and more maintainable layout XML.</p> <p>For more details, please refer to the Notables documentation.</p> <ul> <li>Portman</li> </ul> <p>A tool that enables developers to port packages from other communities into Magento, making it possible to reuse a   wide range of existing code and reduce duplication across ecosystems.</p> <p>For more details, please refer to the Portman documentation.</p> <ul> <li>CSP Complaint</li> </ul> <p>Since April 2025, it is recommended that all payment-related functionality is CSP compliant\u2014meaning that any scripts,   styles, or other resources involved in the payment process must adhere to Content Security Policy standards.</p> <p>This includes using <code>nonces</code> or <code>hashes</code> for inline scripts and ensuring that all external resources are loaded from trusted,   whitelisted domains. Doing so enhances the security of the checkout process and helps prevent cross-site scripting (XSS) attacks.</p> <ul> <li>Components Hooks</li> </ul> <p>Compared to V1, Magewire V3 introduces a wide range of new extension points throughout the backend architecture.   Developers can now hook into various stages of the component lifecycle\u2014including rendering, hydration, dehydration,   and more\u2014making it easier to customize and extend Magewire's behavior in powerful and flexible ways.</p> <ul> <li>View Model Utilities</li> </ul> <p>The primary Magewire ViewModel has been extended with a <code>utils</code> API, giving developers easy access to commonly used   tools\u2014both within and outside Magewire component template files. This eliminates the need to repeatedly create custom   ViewModels for basic functionality.</p> <p>The <code>utils</code> API is designed to be extensible, allowing you to add custom utilities when needed.   However, in most cases, it should already provide everything you need out of the box.</p>"},{"location":"pages/html-directives/wire-click.html","title":"wire:click","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-cloak.html","title":"wire:cloak","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-confirm.html","title":"wire:confirm","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-current.html","title":"wire:current","text":"<p>This Feature is Not Yet Supported</p> <p>This feature is currently not supported by Magewire but may be added in the future. If you're up for the challenge, consider contributing to help bring this feature to Magewire\u2014whether by implementing it fully or in smaller steps.</p> <p>Every contribution helps!</p> <p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-dirty.html","title":"wire:dirty","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-ignore.html","title":"wire:ignore","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-init.html","title":"wire:init","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-loading.html","title":"wire:loading","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-model.html","title":"wire:model","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-offline.html","title":"wire:offline","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-poll.html","title":"wire:poll","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-replace.html","title":"wire:replace","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-show.html","title":"wire:show","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-stream.html","title":"wire:stream","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-submit.html","title":"wire:submit","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-text.html","title":"wire:text","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"pages/html-directives/wire-transition.html","title":"wire:transition","text":"<p>Laravel Livewire Documentation Reference</p> <p>Since Magewire is heavily inspired by Laravel Livewire, many concepts are either identical or very similar. To avoid duplicating documentation, this page only covers Magewire-specific and platform-specific details. For all general concepts and in-depth explanations, you can refer to the corresponding Laravel Livewire documentation.</p> <p> Livewire Reference</p>"},{"location":"blogs/archive/2025.html","title":"2025","text":""}]}